---
title: "Análisis de regresión con modelos lineales generalziados (GLM)"
author: "Carlos M. Guío Blanco"
format: html
editor: visual
---

Este cuaderno implementa en un solo flujo la conexión de R con Google Earth Engine para derivar atributos geomorfométricos e hidroclimáticos satelitales, cuantificar la heterogeneidad interna de estos atributos para cada Unidad Cartográfica de Suelo (UCS) mediante el coeficiente de variación, y finalmente ajustar un modelo logístico que use estas covariables satelitales para explicar la ocurrencia de “hotspots” de pedodiversidad.

**Estructura del script**

1.  **Inicialización**: carga de librerías y autenticación en Earth Engine.
2.  **Carga de vectores**: UCS armonizadas y definición del límite de estudio (Andina, Caribe, Pacífico).
3.  **Derivación de rasters**: cálculo de pendiente y curvaturas (TAGEE), LST y VH/VV.
4.  **Extracción de métricas**: media, desviación estándar y CV por polígono para cada variable.
5.  **Modelado**: ensamblaje de datos y ajuste de un GLM logit ponderado por área para predecir hotspots.

```{r}

#Para exportar como .R plano
# knitr::purl('05_analisis_glm_rao_colombia.qmd')

# Para cargar librerias se verifica pacman
if ("pacman" %in% installed.packages() == FALSE) install.packages("pacman")

# Carga de librerías "inocentes"
pacman::p_load(char = c("here", "remotes", "sf", "geojsonio","dplyr", "ggplot2", "patchwork", "wesanderson", "qs"))



#Selección entorno ya existente antes de cualquier llamado que use Python: only needed while the interpreter path was not yet fixed
reticulate::use_condaenv("rgee_py", required = TRUE) 
#reticulate::py_config() # # Verifica que el python sea Miniconda3/envs/rgee_py/python.exe

# Carga librerías que usan Python
library(reticulate)
library(rgee)
library(googledrive)


# ==== Autenticación y backend Python ====
ee_clean_user_credentials()      # Limpia credenciales de GEE
ee_clean_pyenv()           # Limpia variables de entorno de reticulate
reticulate::py_run_string("import ee; ee.Authenticate()")
reticulate::py_run_string("import ee; ee.Initialize(project='even-electron-461718-g2')")

# ==== Inicializa rgee (ignora asset_home si aparece, ya existe) ====
tryCatch(
  rdee::ee_Initialize(
  drive       = FALSE,                         # or TRUE if you want Drive export
  project     = "even-electron-461718-g2",     # your Cloud Project
  asset_home  = "users/cmguiob_g",             # <-- tell rgee the folder exists
  quiet       = TRUE
),
  error = function(e) message("Si pide asset home y ya existe, solo ESC y sigue")
)
```

Prueba de funcionamiento de rgee

```{r}

# Se consultan datos de DEM
img <- ee$Image("USGS/SRTMGL1_003")

#Consulta que propiedades están disponibles
img$propertyNames()$getInfo()
```

## 1. Carga de datos

**Carga de datos de pedodiversidad de UCS**

Los datos producto del procesamiento de Rao, se han subido a un repositorio de Zenodo.

```{r carga_pedodiversidad}

# Corre script externo para cargar
source(here::here("Scripts", "00_funcion_carga_ucs_procesadas_qs.R"), encoding = "UTF-8")

# Asignación de id único para cada polígono
ucs_rao_sf <- ucs_rao_sf |> mutate(id = row_number())

head(ucs_rao_sf)
```

**Carga de polígono de área de estudio**

Se cargan los polígonos de los departamentos de la zona andina, pacífica y caribe. Se fusionan en uno solo y se armonizan con el crs de pedodiversidad de UCS, para delimitar el área de estudio.

```{r carga_poligono}

# Define ruta y nombre de capa de geopackage de departamentos
deptos_ruta <- here("Data", "INP_departamentos_IGAC_Abril_2025.gpkg")
capa_nombre_deptos <- sf::st_layers(deptos_ruta)$name[1]

# Carga geopackage de dpartamentos
departamentos_sf <- sf::st_read(
  deptos_ruta,
  layer = capa_nombre_deptos,
  quiet = TRUE
  ) |>
  # Se seleccionan 21 departamentos de la zona Andina, Caribe y Pacífica
  dplyr::filter(DeNombre %in% c(
    "Antioquia", 
    "Atlántico",
    "Bolívar",
    "Boyacá",
    "Caldas",
    "Cauca",
    "Cesar",
    "Chocó", 
    "Córdoba",
    "Cundinamarca",
    "Huila",
    "La Guajira",
    "Magdalena",
    "Nariño",
    "Norte de Santander",
    "Quindío",
    "Risaralda",
    "Santander", 
    "Sucre",
    "Tolima",
    "Valle del Cauca")
    ) |>
  tidyr::drop_na()
  

# departamento_1_sf pasa de "SHAPE" a "geometry"
names(departamentos_sf)[names(departamentos_sf) == "SHAPE"] <- "geometry"
departamentos_sf <- sf::st_as_sf(as.data.frame(departamentos_sf), sf_column_name = "geometry")

# Aseguramos que ambos datasets tengan la misma proyección
departamentos_sf <- st_transform(departamentos_sf, st_crs(ucs_rao_sf))

# Se unen los polígonos en uno solo
limite_poly <- st_union(departamentos_sf) 

```

**Conversión a objetos EE**

Convierte objetos de R (ucs_rao_sf y limite_poly, que son sf) en ee\$FeatureCollection, es decir, en objetos que el API de Earth Engine entiende y con los que se puede trabajar directamente en la nube

```{r}


ucs_ee     <- sf_as_ee(ucs_rao_sf)
estudio_ee <- sf_as_ee(limite_poly)

```

## 2. Procesamiento

A continuación se calculan los índices geomorfométricos e hidroclimáticos. Se utiliza TAGEE ...

**DEM**

Suavizado que facilita el cálculo más estable de pendientes y curvaturas, porque atenúa irregularidades puntuales que podrían disparar valores extremos en los derivadores topográficos.

```{r}

# Carga y suavizado del DEM SRTM 30 m
dem_orig   <- ee$Image("USGS/SRTMGL1_003")$rename("DEM")$clip(estudio_ee)
gauss      <- ee$Kernel$gaussian(radius=3, sigma=2, units="pixels", normalize=TRUE)
dem_smooth <- dem_orig$convolve(gauss)$resample("bilinear")

```

Verificación de la operación

```{r}

# 1. Centrar el visor en tu área de interés
Map$setCenter(lon = -74, lat = 4, zoom = 6)

# 2. Añadir el DEM original (sin suavizar)
Map$addLayer(
  dem_orig,
  visParams = list(min = 0, max = 3000,
                   palette = c("blue","green","yellow","red")),
  name = "DEM original"
)

# 3. Añadir el DEM suavizado
Map$addLayer(
  dem_smooth,
  visParams = list(min = 0, max = 3000,
                   palette = c("blue","green","yellow","red")),
  name = "DEM suavizado"
)

```

**Indices derivados del DEM**

Se importa TAGEE...

```{r}

# 7. Importar y ejecutar TAGEE en GEE para atributos de terreno
tagee      <- ee$call("require", "users/zecojls/TAGEE:TAGEE-functions")
dem_attr   <- tagee$terrainAnalysis(tagee, dem_smooth)

```

```{r}

# Selección de bandas y conversión a valor absoluto para curvaturas
slope      <- dem_attr$select("Slope")$rename("slope")
# Para curvaturas, usamos el valor absoluto para que la media no tienda a cero
horiz_curv <- dem_attr$select("HorizontalCurvature")$rename("horiz_curv")$abs()
vert_curv  <- dem_attr$select("VerticalCurvature")$rename("vert_curv")$abs()
```

```{r}

# 9. Visualización espacial en el visor de rgee ----------------------------
Map$setCenter(lon = -74, lat = 4, zoom = 6)
Map$addLayer(slope,      visParams=list(min=0,   max=60, palette=viridis::viridis(10)), name="Pendiente")
Map$addLayer(horiz_curv, visParams=list(min=0,   max=0.15, palette=viridis::magma(10)),  name="Curvatura Horiz. (abs)")
Map$addLayer(vert_curv,  visParams=list(min=0,   max=0.15, palette=viridis::magma(10)),  name="Curvatura Vert. (abs)")
```
