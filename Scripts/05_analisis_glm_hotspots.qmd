---
title: "An√°lisis de regresi√≥n con modelos lineales generalziados (GLM)"
author: "Carlos M. Gu√≠o Blanco"
format: html
editor: visual
---

Este cuaderno implementa en un solo flujo la conexi√≥n de R con Google Earth Engine para derivar atributos geomorfom√©tricos e hidroclim√°ticos satelitales, cuantificar la heterogeneidad interna de estos atributos para cada Unidad Cartogr√°fica de Suelo (UCS) mediante el coeficiente de variaci√≥n, y finalmente ajustar un modelo log√≠stico que use estas covariables satelitales para explicar la ocurrencia de ‚Äúhotspots‚Äù de pedodiversidad.

**Estructura del script**

1.  **Inicializaci√≥n**: carga de librer√≠as y autenticaci√≥n en Earth Engine.
2.  **Carga de vectores**: UCS armonizadas para √°rea de estudio (Andina, Caribe, Pac√≠fico).
3.  **Derivaci√≥n de rasters**: extracci√≥n y c√°lculo de elevac√≥n, pendiente, curvatura vertical (TAGEE), temperatura superficial (Landsat) y VH/VV (Sentinel 1).
4.  **Extracci√≥n de m√©tricas**: media, desviaci√≥n est√°ndar y CV por pol√≠gono para cada variable.
5.  **Modelado**: ensamblaje de datos y ajuste de un GLM logit ponderado por √°rea para predecir hotspots.

```{r configuracion}

#Para exportar como .R plano
# knitr::purl('05_analisis_glm_hotspots.qmd')

if (!"pacman" %in% installed.packages()) install.packages("pacman")
pacman::p_load(here, remotes, sf, geojsonio, geojsonsf, dplyr, purrr, readr, ggplot2,
               patchwork, wesanderson, qs)

# Selecci√≥n entorno ya existente antes de cualquier llamado que use Python
reticulate::use_condaenv("rgee_py", required = TRUE)

## Librer√≠as que usan Python 
library(reticulate)
library(rgee)
library(googledrive)

# ==== Autenticaci√≥n y backend Python ====
ee_clean_user_credentials()      # Limpia credenciales de GEE
ee_clean_pyenv()           # Limpia variables de entorno de reticulate
reticulate::py_run_string("import ee; ee.Authenticate()")
reticulate::py_run_string("import ee; ee.Initialize(project='even-electron-461718-g2')")

# === Autenticaci√≥n Google Drive ===
googledrive::drive_auth()
```

Prueba de funcionamiento de rgee

```{r verifica_configuracion}

# Se consultan datos de DEM
img <- ee$Image("USGS/SRTMGL1_003")

#Consulta que propiedades est√°n disponibles
img$propertyNames()$getInfo()

# Consultar una propiedad espec√≠fica, e.g. keywords
img$get("keywords")$getInfo()
```

## 1. Carga de datos vectoriales

**Carga de datos de pedodiversidad de UCS**

Los datos producto del procesamiento de Rao, se han subido a un repositorio de Zenodo.

```{r carga_pedodiversidad}

# Corre script externo para cargar
source(here::here("Scripts", "00_funcion_carga_ucs_procesadas_qs.R"), encoding = "UTF-8")

# Asignaci√≥n de id √∫nico para cada pol√≠gono
ucs_rao_sf <- ucs_rao_sf |> 
  sf::st_make_valid() |> #valida geometrias problem√°ticas
  dplyr::select(id_creado, UCSuelo, AREA_HA, Q) 

ucs_rao_sf <- ucs_rao_sf[!st_is_empty(ucs_rao_sf), ]

#Se verifica visulalmente
ggplot(data = ucs_rao_sf) +
  geom_sf(aes(fill = UCSuelo), color = NA) +  
  theme_void() +                             
  theme(legend.position = "none") 
```

**Armonizaci√≥n**

Se definen par√°metros de extensi√≥n, CRS y resoluci√≥n para armonizar los datos de GEE con con los datos de pedodiversidad de UCS. Para la definici√≥n del √°rea de recorte se toma un buffer sobre el objeto de sf. Esto amortiguar√° posteriormente efectos de borde en el c√°lculo de la diversidad. No se recomienda enviar el objeto completo y hacer el buffer en GEE, dado que el env√≠o de un ubjeto con numerosos multipoligonos (como es el caso) es prohibitivo en GEE. Los envios no pueden superar 10MB por tarea.

```{r transforma_crs}

# Transforma a crs 4326 antes de pasarlo a GEE
ucs_sf_4326 <- st_transform(ucs_rao_sf, 4326)


# #Extrae bounding boxdel √°rea del subconjunto
bb_sf_4326 <- st_bbox(ucs_sf_4326)

```

Crea geometria de bbox en GEE usando las coordenadas del bbox creado en R con sf.

```{r  tansform_ee}

# Convertir a rect√°ngulo de Earth Engine
bbox_ee <- ee$Geometry$Rectangle(
  coords = list(
    bb_sf_4326["xmin"], 
    bb_sf_4326["ymin"], 
    bb_sf_4326["xmax"], 
    bb_sf_4326["ymax"]
    ),
  geodesic = FALSE
)

```

## 2. Derivaci√≥n de variables raster en GEE

A continuaci√≥n se calculan los √≠ndices geomorfom√©tricos e hidroclim√°ticos. Primero se declaran los objetos raster y se visualizan para verificar. Todos los raster se visualizan en su resoluci√≥n original.

### 2.1 DEM

Se define el objeto raster de elevaci√≥n y se visualiza su extensi√≥n.

```{r extraccion_dem}

# Carga y suavizado del DEM SRTM 30 m
dem_clip <- ee$Image("USGS/SRTMGL1_003")$clip(bbox_ee)

# Visualiza en el visor antes de exportar (verifica recorte)
Map$setCenter(lon = -74, lat = 4, zoom = 5)
Map$addLayer(
  dem_clip,
  visParams = list(min = 0, max = 3000,
                   palette = viridis::viridis(10)), 
  name = "DEM SRTM (nativo 30m)"
  )

```

### 2.2 Pendiente

```{r extraccion_pendiente}

# Procesamiento de pendiente (slope) a partir del SRTM
slope_clip <- ee$Terrain$
  slope(ee$Image("USGS/SRTMGL1_003"))$
  clip(bbox_ee)$
  multiply(180/pi)$
  rename("slope_deg")

# Visualiza en el visor antes de exportar (verifica recorte)
Map$setCenter(lon = -74, lat = 4, zoom = 5)
Map$addLayer(
  slope_clip,
  visParams = list(min = 0, max = 360,
                   palette = viridis::viridis(10)), 
  name = "Pendiente SRTM (nativo 30m)"
  )
```

### 2.3 Curvatura vertical

A continuaci√≥n se invoca la funci√≥n terrainAnalysis del m√≥dulo TAGEE en GEE. Al hacerlo se calcula en la nube de Earth Engine un conjunto completo de atributos geomorfom√©tricos a partir del DEM de entrada.TAGEE utliza un DEM base de ...

Cada vez que se llama a py_install() o importa un nuevo m√≥dulo con reticulate::import(), reticulate reinicia o ‚Äúreconfigure‚Äù el int√©rprete Python, y por tanto se debe repetir la inicializaci√≥n de Earth Engine.

```{r}

# Bloque √∫nico de setup (solo la primera vez)
if (!py_module_available("tagee")) {
  py_install(c("tagee","ee_extra","regex","jsbeautifier"),
             envname="rgee_py", pip=TRUE)
}
tagee <- import("tagee",    convert = FALSE)
eeextra <- import("ee_extra", convert = FALSE)

reticulate::py_run_string("import ee; ee.Initialize(project='even-electron-461718-g2')")

# Ejecuta el an√°lisis de terreno (devuelve un ee$Image con m√∫ltiples bandas)
dem_attr <- tagee$terrainAnalysis(dem)

# Extrae la banda de Curvatura Vertical
vc_clip <- dem_attr$select("VerticalCurvature")$clip(bbox_ee)


Map$setCenter(lon = -74, lat = 4, zoom = 5)
Map$addLayer(
  vc_clip,
  visParams = list(
    min     = -0.00005,
    max     = +0.00005,
    palette = viridis::viridis(5)
  ),
  name = "Curvatura vertical (¬±0.00005)"
)

```

### 2.4 Temperatura superficial

La temperatura superficial se obtiene a partir de im√°genes de Landsat 8, las cuales tienen resoluci√≥n de 100m. Se obitene en unidades de ... se transforma...

```{r}

# Temperatura superficial (LST)
lst_media <- ee$ImageCollection("LANDSAT/LC08/C02/T1_L2")$
  filterBounds(bbox_ee)$
  filterDate("2013-01-01", "2023-01-01")$
  map(function(img) {
    img$select("ST_B10")$multiply(0.00341802)$add(149)
  })$
  median()$
  rename("lst")

# Visualizaci√≥n
Map$setCenter(-74, 4, 5)
Map$addLayer(
  lst_media,
  visParams = list(min = 270, max = 320, palette = c("blue","white","red")),
  name  = "LST mediana"
)

```

### 2.5 √çndice de polarizaci√≥n

```{r}

vhvv_media <- ee$ImageCollection("COPERNICUS/S1_GRD")$
  filterBounds(bbox_ee)$
  filterDate("2015-01-01", "2024-01-01")$
  filter(ee$Filter$listContains("transmitterReceiverPolarisation", "VV"))$
  filter(ee$Filter$listContains("transmitterReceiverPolarisation", "VH"))$
  map(function(img) {
    img$select("VH")$
      divide(img$select("VV"))$
      rename("vhvv")
  })$
  median()$
  rename("vhvv")

# Visualizaci√≥n en el visor de rgee
Map$setCenter(lon = -74, lat = 4, zoom = 5)
Map$addLayer(
  vhvv_media,
  visParams = list(min = 0, max = 2, palette = c("brown", "white", "blue")),
  name = "VH/VV mediana"
)

```

## 3. Extracci√≥n de m√©tricas

La funci√≥n se encuentra en un script externo. Esta ...

...los raster se muestrean a 50m si su resoluci√≥n es mas fina, lo cual equivale a escala 1:100.000. Si la resoluci√≥n es mas gruesa, se utiliza la que est√© disponible.

```{r}

source(here::here("Scripts", "00_funcion_procesamiento_lotes_imagen.R"), encoding = "UTF-8")

registro_dem <- procesamiento_lotes_imagen(ucs_sf_4326, image = dem_clip, start_idx = 1, max_index = 43384, variable_name = "DEM", scale = 50)

registro_slope <- procesamiento_lotes_imagen(ucs_sf_4326, image = slope_clip, start_idx = 1, max_index = 43384, variable_name = "SLOPE", scale = 50)


registro_lst <- procesamiento_lotes_imagen(ucs_sf_4326, image = lst_media, start_idx = 1, max_index = 43384, variable_name = "LST_media", scale = 100)

registro_vvvh <- procesamiento_lotes_imagen(ucs_sf_4326, image = vhvv_media, start_idx = 1, max_index = 43384, variable_name = "VHVV_media", scale = 50)


```

**Post procesamiento de .csv**

El c√≥digo a continuaci√≥n lee todos los .csv de una propiedad (por ejemplo, "slope"),los combina en un solo data.frame, lo guarda como OUT_slope_combinado.csv (o OUT\_<propiedad>\_combinado.csv seg√∫n corresponda), y lo sube autom√°ticamente al repositorio del proyecto, usando el paquete googledrive.

```{r reubicar_googledrive}

combinar_y_subir_csv <- function(propiedad,
                                 carpeta_drive_id_origen = "17yxwhlpgL4EG8inI5u8Nwi08wOrnhJiM",  # GEE_exports
                                 carpeta_drive_id_destino = "1qJ5S25TZaFWzueNhx1M4Gr3P8JYWKGeU",  # Proyecto
                                 carpeta_temporal = "tmp_csv") {

  # Crea carpeta temporal local si no existe
  if (!dir.exists(carpeta_temporal)) {
    dir.create(carpeta_temporal)
  }

  # Listar archivos en Google Drive (solo .csv con prefijo exacto)
  archivos_drive <- googledrive::drive_ls(
    path = as_id(carpeta_drive_id_origen),
    pattern = glue::glue("^{propiedad}_.*\\.csv$")
  ) |>
    dplyr::filter(stringr::str_ends(name, ".csv"))

  if (nrow(archivos_drive) == 0) {
    stop(glue::glue("No se encontraron archivos CSV para la propiedad '{propiedad}' en GEE_exports."))
  }

  message(glue::glue("üì• Descargando {nrow(archivos_drive)} archivos CSV para '{propiedad}'..."))

  # Descargar archivos al directorio temporal
  purrr::walk2(
    archivos_drive$name,
    archivos_drive$id,
    ~ googledrive::drive_download(
      file = as_id(.y),
      path = file.path(carpeta_temporal, .x),
      overwrite = TRUE
    )
  )

  # Leer y combinar
  archivos_locales <- list.files(path = carpeta_temporal,
                                 pattern = paste0("^", propiedad, "_.*\\.csv$"),
                                 full.names = TRUE)

  combinado <- purrr::map_dfr(archivos_locales, readr::read_csv, show_col_types = FALSE)

  # Escribir archivo combinado
  nombre_salida <- paste0("OUT_", propiedad, "_combinado.csv")
  ruta_salida <- file.path(carpeta_temporal, nombre_salida)
  readr::write_csv(combinado, ruta_salida)

  # Subir a carpeta final de proyecto en Drive
  archivo_subido <- googledrive::drive_upload(
    media = ruta_salida,
    path = as_id(carpeta_drive_id_destino),
    name = nombre_salida,
    overwrite = TRUE
  )

  message(glue::glue("‚úÖ Archivo combinado subido: {archivo_subido$name} (ID: {archivo_subido$id})"))

  # Limpieza autom√°tica
  unlink(carpeta_temporal, recursive = TRUE)
  message("üßπ Archivos temporales eliminados.")
}

```

Aplica la funci√≥n para las covariables

```{r}

combinar_y_subir_csv("DEM")

combinar_y_subir_csv("SLOPE")
```

Se convierte geometria de geojson a sf

```{r}


# Ruta al CSV combinado
dem_cv <- read_csv(here::here("Data", "OUT_covars_csv","OUT_DEM_combinado.csv" ))

# Convierte geometr√≠a desde .geo (GeoJSON como texto) a objeto sf
dem_cv_sf <- st_as_sf(
  data.frame(dem_cv, geometry = geojson_sf(dem_cv$.geo)), #convierte a sf
  crs = 4326) |>
  select(-.geo) |> #elimina columna de geometria obsoleta
  mutate(cv = stdDev / mean) #calcula coeficiente de variaci√≥n

# Ruta al CSV combinado
slope_cv <- read_csv(here::here("Data", "OUT_covars_csv","OUT_SLOPE_combinado.csv" ))

# Convierte geometr√≠a desde .geo (GeoJSON como texto) a objeto sf
slope_cv_sf <- st_as_sf(
  data.frame(slope_cv, geometry = geojson_sf(slope_cv$.geo)), #convierte a sf
  crs = 4326) |>
  select(-.geo) |> #elimina columna de geometria obsoleta
  mutate(cv = stdDev / mean) #calcula coeficiente de variaci√≥n


```

Se a√±aden columnas de log

```{r}

# Inicializa vector de estado
status_vector <- rep(NA_character_, nrow(dem_cv_sf))

# Recorre el log y asigna el estado a cada fila seg√∫n rango
for (i in seq_len(nrow(registro_dem))) {
  fila_inicio <- registro_dem$start_idx[i]
  fila_fin    <- registro_dem$end_idx[i]
  status_val  <- registro_dem$status[i]

  status_vector[fila_inicio:fila_fin] <- status_val
}

# A√±adir al objeto sf
dem_cv_sf$status <- status_vector
```

## 4. Modelado GLM
