---
title: "AnÃ¡lisis de exploratorio de covariables"
author: "Carlos M. GuÃ­o Blanco"
format: html
editor: visual
---

Este cuaderno implementa en un solo flujo la conexiÃ³n de R con Google Earth Engine para derivar atributos geomorfomÃ©tricos e hidroclimÃ¡ticos satelitales, cuantificar la heterogeneidad interna de estos atributos para cada Unidad CartogrÃ¡fica de Suelo (UCS) mediante el coeficiente de variaciÃ³n,

**Estructura del script**

1.  **InicializaciÃ³n**: carga de librerÃ­as y autenticaciÃ³n en Earth Engine.
2.  **Carga de vectores**: UCS armonizadas para Ã¡rea de estudio (Andina, Caribe, PacÃ­fico).
3.  **DerivaciÃ³n de rasters**: extracciÃ³n y cÃ¡lculo de elevacÃ³n, pendiente, curvatura vertical (TAGEE), temperatura superficial (Landsat) y VH/VV (Sentinel 1).
4.  **ExtracciÃ³n de mÃ©tricas**: media, desviaciÃ³n estÃ¡ndar y CV por polÃ­gono para cada variable.

```{r configuracion}

#Para exportar como .R plano
# knitr::purl('03_analisis_eda_covariables.qmd')

if (!"pacman" %in% installed.packages()) install.packages("pacman")
pacman::p_load(
  here,        # rutas relativas del proyecto
  sf,          # lectura y manipulaciÃ³n de objetos espaciales vectoriales
  httr,        # peticiones HTTP REST (consulta servicio Mapa GeolÃ³gico)
  geojsonsf,   # GeoJSON â†” sf rÃ¡pido (geojson_sf)
  dplyr,       # gramÃ¡tica de datos: mutate, select, joins
  tidyr,       # âœ— (no usado; pivot, unnestâ€¦)
  stringr,     # utilidades de texto y regex
  purrr,       # programaciÃ³n funcional: map*, walk*
  broom,       # âœ— (no usado; tidy de modelos)
  readr,       # lectura/escritura rÃ¡pida de CSV
  ggdist,      # distribuciones y â€˜raincloudâ€™/histinterval
  scales,      # transformaciones y breaks de ejes
  ggplot2,     # visualizaciÃ³n de datos
  paletteer,    # paletas de colores
  patchwork,   # combinaciÃ³n de grÃ¡ficos ggplot
  wesanderson, # paletas continuas y discretas
  qs           # âœ— (no usado; serializaciÃ³n rÃ¡pida .qs)
)

#Paleta de colores
pal <- wes_palette("Zissou1", 100, type = "continuous")

# Ajusta tamaÃ±o de letra para todo e lscript
theme(base_size = 14)

# SelecciÃ³n entorno ya existente antes de cualquier llamado que use Python
reticulate::use_condaenv("rgee_py", required = TRUE)

## LibrerÃ­as que usan Python 
library(reticulate)
library(rgee)
library(googledrive)

# ==== AutenticaciÃ³n y backend Python ====
# Se fuerzan credenciales limpias para evitar colisiones de proyectos GEE entre sesiones
ee_clean_user_credentials()      # Limpia credenciales de GEE
ee_clean_pyenv()           # Limpia variables de entorno de reticulate
reticulate::py_run_string("import ee; ee.Authenticate()")
reticulate::py_run_string("import ee; ee.Initialize(project='even-electron-461718-g2')") #cuenta gmail propia
#reticulate::py_run_string("import ee; ee.Initialize(project='optimal-signer-459113-i1')") #cuenta UNAL

# === AutenticaciÃ³n Google Drive ===
googledrive::drive_auth()
```

Prueba de funcionamiento de rgee

```{r verifica_configuracion}

# Se consultan datos de DEM
img <- ee$Image("USGS/SRTMGL1_003")

#Consulta que propiedades estÃ¡n disponibles
img$propertyNames()$getInfo()

# Consultar una propiedad especÃ­fica, e.g. keywords
img$get("keywords")$getInfo()
```

## 1. Carga de datos vectoriales

### 1.1 Carga de datos de pedodiversidad de UCS

Los datos producto del procesamiento de Rao, se han subido a un repositorio de Zenodo. Estos se utilizan acÃ¡ para derivar las covariables a nivel de polÃ­gono de UCS. Por tal razÃ³n, solo se importan variables que no tengan NAs.

```{r carga_pedodiversidad}

# Corre script externo para cargar
source(here::here("Scripts", "00_funcion_carga_ucs_procesadas_qs.R"), encoding = "UTF-8")

# AsignaciÃ³n de id Ãºnico para cada polÃ­gono
ucs_rao_sf <- ucs_rao_sf |> 
  sf::st_make_valid() |> #valida geometrias problemÃ¡ticas
  dplyr::select(id_creado, UCSuelo, AREA_HA) 

ucs_rao_sf <- ucs_rao_sf[!st_is_empty(ucs_rao_sf), ]

#Se verifica visulalmente
ggplot(data = ucs_rao_sf) +
  geom_sf(aes(fill = UCSuelo), color = NA) +  
  theme_void() +                             
  theme(legend.position = "none") 
```

### 1.2 Carga de datos de unidades geolÃ³gicas SGC

Las unidades geolÃ³gicas son un insumo que se utilizarÃ¡ posteriormente para los modelos jerÃ¡rquicos. Estos datos se cargan via API del servicio de ArcGIS que usa el Servicio GeolÃ³gico Colombiano. No requieren token.

```{r geologia_descarga_reclasificacion}

# Se desagrega la url bÃ¡sica en sus componentes
url <- httr::parse_url("https://srvags.sgc.gov.co/arcgis/rest/services/Mapa_Geologico_Colombia/Mapa_Geologico_Colombia_V2023/MapServer")

layer_id <- "733"

url$path <- paste(url$path, layer_id, "query", sep = "/")

# Se agregan componentes a la URL para solicitud de informaciÃ³n
url$query <- list(where = "1=1", # para recuperar todos los features
                  outFields = "*", #para recuperar todos los campos
                  returnGeometry = "true", #retorna geometrias
                  f = "geojson") #retorna formato geojson

# Se construye la url
url_solicitud <- httr::build_url(url)

# Para recuperar los datos espaciales se usa la librerÃ­a sf
respuesta <- httr::GET(url_solicitud)

#Se examina la respuesta
print(respuesta)

# Descarga del mapa geolÃ³gico 1 : 500 000 y clasificaciÃ³n de unidades por era (mÃ¡s joven)
geo_sf_wgs84 <- sf::st_read(url_solicitud) |>
  sf::st_make_valid() |>
  mutate(
    # LIMPIEZA -----------------------------------------------------------------
    edad_limpia = Edad %>% 
      str_replace_all("\\?", "") %>%    # quita â€œ?â€
      str_trim() %>%                    # quita espacios extremos
      str_squish(),                     # colapsa espacios mÃºltiples
    
    # RECLASIFICACIÃ“N POR ERA (la MÃS JOVEN domina) ----------------------------
    era_geo = case_when(
      # 1) CENOZOICO  ----------------------------------------------------------
      str_detect(edad_limpia, regex(
        "paleoceno|eoceno|oligoceno|mioceno|plioceno|pleistoceno|holoceno|
         aquitaniano|burdigaliano|langhiano|serravaliano|tortoniano|messiniano|
         zancliano|rupeliano|thanetiano|lutetiano|bartoniano|priaboniano|
         selandiano|daniense|chattiano",
        ignore_case = TRUE)
      ) ~ "Cenozoico",
      
      # 2) MESOZOICO  ----------------------------------------------------------
      str_detect(edad_limpia, regex(
        "triÃ¡sico|jurÃ¡sico|cretÃ¡cico|berriasiano|valanginiano|barremiano|
         aptiano|albiano|cenomaniano|turoniano|coniaciano|santoniano|
         campaniano|maastrichtiano",
        ignore_case = TRUE)
      ) ~ "Mesozoico",
      
      # 3) PALEOZOICO ----------------------------------------------------------
      str_detect(edad_limpia, regex(
        "cÃ¡mbrico|ordovÃ­cico|silÃºrico|devÃ³nico|mississipiano|pridoliano|
         carbonÃ­fero|pennsylvaniano|pÃ©rmico",
        ignore_case = TRUE)
      ) ~ "Paleozoico",
      
      # 4) PROTEROZOICO --------------------------------------------------------
      str_detect(edad_limpia, regex(
        "sideriano|rhyaciano|orosiriano|statheriano|calymmiano|ectasiano|
         steniano|toniano|criogÃ©nico|ediacariano|mesoproterozoico|
         neoproterozoico|proterozoico",
        ignore_case = TRUE)
      ) ~ "Proterozoico",
      
      # 5) SIN DATO ------------------------------------------------------------
      TRUE ~ "Sin_dato"
    )
  ) |>
  select(descripcion_geo = Descripcion, era_geo)



#Se visualizan datos geogrÃ¡ficamente (edad, sin leyenda)
p_mapa_geo <- ggplot2::ggplot(geo_sf_wgs84) +
  geom_sf(aes(fill = era_geo), color = NA) +
  scale_fill_manual(
    name   = "Era geolÃ³gica",                         # (1) tÃ­tulo de la leyenda
    breaks = c("Cenozoico", "Mesozoico",              # (3) orden joven â†’ antiguo
               "Paleozoico", "Proterozoico", "Sin_dato"),
    values = c(                                       # (2) colores por categorÃ­a
      Cenozoico   = "#f8ea1e",
      Mesozoico   = "#5bc5ea",
      Paleozoico  = "#a9c6a8",
      Proterozoico= "#ea5173",
      Sin_dato    = "gray90"
    ),
    drop = FALSE                                      # muestra todas las clases aunque falten
  ) +
  theme_minimal()

p_mapa_geo
```

### 1.3 ArmonizaciÃ³n con GEE

Se definen parÃ¡metros de extensiÃ³n, CRS y resoluciÃ³n para armonizar los datos de GEE con con los datos de pedodiversidad de UCS. Para la definiciÃ³n del Ã¡rea de recorte se toma un buffer sobre el objeto de sf. Esto amortiguarÃ¡ posteriormente efectos de borde en el cÃ¡lculo de la diversidad. No se recomienda enviar el objeto completo y hacer el buffer en GEE, dado que el envÃ­o de un ubjeto con numerosos multipoligonos (como es el caso) es prohibitivo en GEE. Los envios no pueden superar 10MB por tarea.

```{r transforma_crs}

# Transforma a crs 4326 antes de pasarlo a GEE
ucs_sf_4326 <- st_transform(ucs_rao_sf, 4326)


# #Extrae bounding boxdel Ã¡rea del subconjunto
bb_sf_4326 <- st_bbox(ucs_sf_4326)

```

Crea geometria de bbox en GEE usando las coordenadas del bbox creado en R con sf.

```{r  tansform_ee}

# Convertir a rectÃ¡ngulo de Earth Engine
bbox_ee <- ee$Geometry$Rectangle(
  coords = list(
    bb_sf_4326["xmin"], 
    bb_sf_4326["ymin"], 
    bb_sf_4326["xmax"], 
    bb_sf_4326["ymax"]
    ),
  geodesic = FALSE
)

```

## 2. DerivaciÃ³n de variables raster en GEE

A continuaciÃ³n se calculan los Ã­ndices geomorfomÃ©tricos e hidroclimÃ¡ticos. Primero se declaran los objetos raster y se visualizan para verificar. Todos los raster se visualizan en su resoluciÃ³n original.

### 2.1 DEM

Se define el objeto raster de elevaciÃ³n y se visualiza su extensiÃ³n.

```{r extraccion_dem}

# Carga y suavizado del DEM SRTM 30 m
dem_clip <- ee$Image("USGS/SRTMGL1_003")$clip(bbox_ee)

# Visualiza en el visor antes de exportar (verifica recorte)
Map$setCenter(lon = -74, lat = 4, zoom = 5)
Map$addLayer(
  dem_clip,
  visParams = list(min = 0, max = 3000,
                   palette = viridis::viridis(10)), 
  name = "DEM SRTM (nativo 30m)"
  )

```

### 2.2 Pendiente

```{r extraccion_pendiente}

# Procesamiento de pendiente (slope) a partir del SRTM
slope_clip <- ee$Terrain$
  slope(ee$Image("USGS/SRTMGL1_003"))$
  clip(bbox_ee)$
  rename("slope_deg")  # valores ya estÃ¡n en grados

# Visualiza en el visor antes de exportar (verifica recorte)
Map$setCenter(lon = -74, lat = 4, zoom = 5)
Map$addLayer(
  slope_clip,
  visParams = list(min = 0, max = 50,
                   palette = viridis::viridis(10)), 
  name = "Pendiente SRTM (nativo 30m)"
  )
```

### 2.3 Curvatura vertical

A continuaciÃ³n se invoca la funciÃ³n terrainAnalysis del mÃ³dulo TAGEE en GEE. Al hacerlo se calcula en la nube de Earth Engine un conjunto completo de atributos geomorfomÃ©tricos a partir del DEM de entrada.TAGEE utliza un DEM base de ...

Cada vez que se llama a py_install() o importa un nuevo mÃ³dulo con reticulate::import(), reticulate reinicia o â€œreconfigureâ€ el intÃ©rprete Python, y por tanto se debe repetir la inicializaciÃ³n de Earth Engine.

```{r}

# Bloque Ãºnico de setup (solo la primera vez)
if (!py_module_available("tagee")) {
  py_install(c("tagee","ee_extra","regex","jsbeautifier"),
             envname="rgee_py", pip=TRUE)
}
tagee <- import("tagee",    convert = FALSE)
eeextra <- import("ee_extra", convert = FALSE)

reticulate::py_run_string("import ee; ee.Initialize(project='even-electron-461718-g2')")

# Ejecuta el anÃ¡lisis de terreno (devuelve un ee$Image con mÃºltiples bandas)
dem_attr <- tagee$terrainAnalysis(dem_clip)

# Extrae la banda de Curvatura Vertical
vc_clip <- dem_attr$select("VerticalCurvature")$clip(bbox_ee)


Map$setCenter(lon = -74, lat = 4, zoom = 5)
Map$addLayer(
  vc_clip,
  visParams = list(
    min     = -0.00005,
    max     = +0.00005,
    palette = viridis::viridis(5)
  ),
  name = "Curvatura vertical (Â±0.00005)"
)

```

### 2.4 Temperatura superficial

La temperatura superficial se obtiene del producto MODIS MOD11A2 v6.1, un compuesto de 8 dÃ­as a 1 km de resoluciÃ³n generado a partir de las observaciones diurnas del sensor tÃ©rmico de Terra. Para garantizar una cobertura homogÃ©nea, se emplea toda la serie de 2013 â€“ 2023 (â‰ˆ 460 compuestos por pÃ­xel). A partir de esta colecciÃ³n se derivan dos conjuntos de datos recortados al Ã¡rea de estudio (bbox):

-   Media espacial decenal â€“ promedio de la LST (Â°C) de los 460 compuestos, que describe la temperatura superficial promedio del Ãºltimo decenio.

-   Coeficiente de variaciÃ³n temporal â€“ relaciÃ³n entre la desviaciÃ³n estÃ¡ndar y la media (Ïƒ / Î¼) de la misma serie, indicador de cuÃ¡n variable ha sido la temperatura en cada pÃ­xel a lo largo de diez aÃ±os.

Ambas capas se promedian despuÃ©s dentro de cada polÃ­gono UCS para incorporarlas como covariables tÃ©rmicas en los modelos de pedodiversidad.

**MODIS LST â€” Media espacial (8-dÃ­as, 1 km)**

En este bloque cargamos el producto MOD11A2 v6.1 (compuesto de 8 dÃ­as, 1 km, temperatura superficial diurna). Cada compuesto ya promedia las observaciones diarias â€œclarasâ€ dentro de su intervalo. Al convertir todos los compuestos de 2013-2023 a Â°C y aplicar mean(), obtenemos para cada pÃ­xel la LST diurna media decenal. Esta capa resume la temperatura superficial tÃ­pica del Ãºltimo decenio y se usarÃ¡ como indicador tÃ©rmico basal para cada polÃ­gono de suelos.

```{r}


# =============================================================================
# ColecciÃ³n MODIS MOD11A2 (8-dÃ­as, 1 km) convertida a Â°C
# =============================================================================
modis_collection <- ee$ImageCollection("MODIS/061/MOD11A2")$
  filterBounds(bbox_ee)$              # descarta las imÃ¡genes cuyo footprint no toca tu bbox_ee
  filterDate("2013-01-01", "2023-01-01")$
  map(function(img) {
    img$select("LST_Day_1km")$        # banda de temperatura diurna
      multiply(0.02)$                 # factor de escala
      subtract(273.15)$               # K â†’ Â°C
      rename("lst_celsius")$
      clip(bbox_ee)                   # recorte geomÃ©trico
  })

# â”€â”€ MEDIA ESPACIAL POR PÃXEL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
modis_media_espacial <- modis_collection$mean()$rename("modis_media_espacial")

# VerificaciÃ³n visual en el visor de Earth Engine
Map$setCenter(lon = -74, lat = 4, zoom = 5)
Map$addLayer(
  modis_media_espacial, 
  list(min = 10, max = 45, palette = c("blue","white","red")),
  "MODIS LST media (Â°C)"
)



```

**MODIS LST â€” Coeficiente de variaciÃ³n temporal (8-dÃ­as, 1 km)**

Partiendo de la misma colecciÃ³n MOD11A2 (2013-2023) derivamos primero la media y la desviaciÃ³n estÃ¡ndar de la serie de 8 dÃ­as para cada pÃ­xel; su cociente (Ïƒ / Î¼) nos da el coeficiente de variaciÃ³n temporal (CV). Este mapa refleja quÃ© tan inestable es la temperatura superficial a lo largo de los 10 aÃ±os: valores altos indican variabilidad tÃ©rmica marcada, valores bajos un rÃ©gimen mÃ¡s estable.

```{r}

# =============================================================================
# ColecciÃ³n MODIS MOD11A2 (8-dÃ­as, 1 km) convertida a Â°C
# =============================================================================
modis_collection <- ee$ImageCollection("MODIS/061/MOD11A2")$
  filterBounds(bbox_ee)$              # descarta las imÃ¡genes cuyo footprint no toca tu bbox_ee
  filterDate("2013-01-01", "2023-01-01")$
  map(function(img) {
    img$select("LST_Day_1km")$        # banda de temperatura diurna
      multiply(0.02)$                 # factor de escala
      subtract(273.15)$               # K â†’ Â°C
      rename("lst_celsius")$
      clip(bbox_ee)                   # recorte geomÃ©trico
  })

# â”€â”€ CV TEMPORAL POR PÃXEL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
modis_temp_mean <- modis_collection$mean()$rename("modis_temp_mean")
modis_temp_sd   <- modis_collection$reduce(ee$Reducer$stdDev())$rename("modis_temp_sd")
modis_temp_cv   <- modis_temp_sd$divide(modis_temp_mean)$rename("modis_temp_cv")

# VerificaciÃ³n visual en el visor de Earth Engine
Map$setCenter(lon = -74, lat = 4, zoom = 5)
Map$addLayer(
  modis_temp_cv, 
  list(min = 0, max = 0.15, palette = c("blue","orange","red")),
  "MODIS LST CV temporal"
)

```

### 2.5 PrecipitaciÃ³n

La precipitaciÃ³n se extrae del producto CHIRPS v2.1 Daily (Climate Hazards Group InfraRed Precipitation with Station data). CHIRPS combina estimaciones satelitales e informaciÃ³n de pluviÃ³metros en una rejilla de 0,05 Â° (\~ 5,5 km), con cobertura cuasi-global desde 1981. Para asegurar una serie homogÃ©nea usamos todo el intervalo 2013 â€“ 2023 (datos diarios).

**PrecipitaciÃ³n media espacial (CHIRPS, 2013-2023)**

A partir de la misma serie diaria de CHIRPS se agrega primero a **totales mensuales** y luego se promedia esos 120 meses (2013-2023). El resultado es, para cada pÃ­xel, la **precipitaciÃ³n media mensual acumulada** (mm Â· mesâ»Â¹) representativa de la Ãºltima dÃ©cada. Al reducir esta capa sobre los polÃ­gonos de suelos obtenemos, para cada UCS, un indicador directo de disponibilidad hÃ­drica promedio â€’en la misma unidad temporal del CV mensualâ€’ que se incorporarÃ¡ como covariable en los modelos de pedodiversidad.

```{r}

# (1) ColecciÃ³n diaria recortada al bbox
chirps_daily <- ee$ImageCollection("UCSB-CHG/CHIRPS/DAILY")$
  filterBounds(bbox_ee)$
  filterDate("2013-01-01", "2023-01-01")

# (2) AgregaciÃ³n mensual  (mm por mes)
chirps_monthly_ic <- ee$ImageCollection(
  ee$List$sequence(2013, 2023)$map(ee_utils_pyfunc(function(y) {
    ee$List$sequence(1, 12)$map(ee_utils_pyfunc(function(m) {
      start <- ee$Date$fromYMD(y, m, 1)
      end   <- start$advance(1, "month")
      chirps_daily$
        filterDate(start, end)$
        sum()$                      # mm del mes
        clip(bbox_ee)$
        set("system:time_start", start)
    }))
  }))$flatten()
)

# (3) Media mensual (mm Â· mesâ»Â¹) por pÃ­xel en 2013â€“2023
precip_media_espacial <- chirps_monthly_ic$
  mean()$
  rename("precip_media_espacial")$
  clip(bbox_ee)

# (4) Vista rÃ¡pida en el visor de Earth Engine
Map$setCenter(lon = -74, lat = 4, zoom = 5)
Map$addLayer(
  precip_media_espacial,
  list(min = 0, max = 800, palette = c("blue", "white", "red")),
  "CHIRPS Â· media mensual (mm/mes)"
)

```

**CV temporal de la precipitaciÃ³n (CHIRPS, 2013-2023)**

Para cuantificar cuÃ¡n irregular es la lluvia a lo largo del aÃ±o, tomamos la serie diaria CHIRPS (0,05Â° â‰ˆ 5 km) y la agregamos a totales mensuales por pÃ­xel. Sobre los 132 meses resultantes (enero 2013 â€“ diciembre 2023) calculamos, para cada celda, la media y la desviaciÃ³n estÃ¡ndar de esos totales y derivamos el coeficiente de variaciÃ³n (CV = Ïƒ / Î¼).

El mapa final resalta los lugares donde la precipitaciÃ³n mensual es mÃ¡s variable: valores altos indican regÃ­menes pluviales muy irregulares, mientras que valores bajos corresponden a climas con lluvias mÃ¡s estables en el tiempo. Al promediar este CV dentro de cada UCS obtendremos una medida de variabilidad climÃ¡tica propia de cada polÃ­gono. La relaciÃ³n del CV con la media para cada lugar permite una interpretaciÃ³n directa (p. ej. â€œpara un mes tÃ­pico de lluvia de 300 mm/mes, un CV de 0,6 significa que la precipitaciÃ³n mensual tÃ­pica varÃ­a un 60 % alrededor de 300 mm/mes, indicando un rÃ©gimen muy irregularâ€).

```{r}

# ColecciÃ³n diaria recortada
chirps_daily <- ee$ImageCollection("UCSB-CHG/CHIRPS/DAILY")$
  filterBounds(bbox_ee)$  #descarta las imÃ¡genes cuyo footprint no toca tu bbox_ee
  filterDate("2013-01-01", "2023-01-01")

# â”€â”€ AgregaciÃ³n mensual (mm por mes) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
chirps_monthly_ic <- ee$ImageCollection(
  ee$List$sequence(2013, 2023)$map(ee_utils_pyfunc(function(y) {
    ee$List$sequence(1, 12)$map(ee_utils_pyfunc(function(m) {
      start <- ee$Date$fromYMD(y, m, 1)
      end   <- start$advance(1, "month")
      chirps_daily$
        filterDate(start, end)$
        sum()$                         # mm del mes
        clip(bbox_ee)$
        set("system:time_start", start)
    }))
  }))$flatten()
)

# â”€â”€ (1) CV TEMPORAL POR PÃXEL (mensual) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
precip_mean_temp <- chirps_monthly_ic$mean()$rename("precip_mean_temp")
precip_sd_temp   <- chirps_monthly_ic$reduce(ee$Reducer$stdDev())$rename("precip_sd_temp")
precip_cv_temp   <- precip_sd_temp$divide(precip_mean_temp)$rename("precip_cv_temp")

# VerificaciÃ³n visual en el visor de Earth Engine
Map$setCenter(lon = -74, lat = 4, zoom = 5)
Map$addLayer(
  precip_cv_temp,
  list(min = 0, max = 1, palette = c("blue","orange","red")),
  "Precip CV temporal (mensual)"
)

```

## 3. ExtracciÃ³n de mÃ©tricas

Falta texto coherence: La funciÃ³n se encuentra en un script externo.... rgee para la extracciÃ³n. ...los raster se muestrean a 50m si su resoluciÃ³n es mas fina, lo cual equivale a escala 1:100.000. Si la resoluciÃ³n es mas gruesa, se utiliza la que estÃ© disponible.

```{r exporta_covariables_poligonos}

# Extrae estadÃ­sticas (mean / sd) por UCS y las envÃ­a a Drive en lotes adaptativos
source(here::here("Scripts", "00_funcion_procesamiento_lotes_imagen.R"), encoding = "UTF-8")

registro_dem <- procesamiento_lotes_imagen(ucs_sf_4326, image = dem_clip, start_idx = 1, max_index = 43384, variable_name = "DEM", scale = 50)

registro_slope <- procesamiento_lotes_imagen(ucs_sf_4326, image = slope_clip, start_idx = 1, max_index = 43384, batch_s = 400, reduce_batch_by = 4, variable_name = "SLOPE", scale = 50)

registro_lst_esp <- procesamiento_lotes_imagen(ucs_sf_4326, image = modis_media_espacial, start_idx = 1, max_index = 43384, batch_s = 300, reduce_batch_by = 3, variable_name = "LST_media_espacial", scale = 500)

registro_lst_temp <- procesamiento_lotes_imagen(ucs_sf_4326, image = modis_temp_cv, start_idx = 1, max_index = 43384, batch_s = 300, reduce_batch_by = 3, variable_name = "LST_cv_temporal", scale = 500)

registro_precip_cv_temporal <- procesamiento_lotes_imagen(ucs_sf_4326, image = precip_cv_temp, start_idx = 1, max_index = nrow(ucs_sf_4326), batch_s = 300, reduce_batch_by = 3, variable_name  = "PRECIP_cv_temporal", scale = 500)

registro_precip_esp <- procesamiento_lotes_imagen(ucs_sf_4326, image = precip_media_espacial, start_idx = 1, max_index = 43384, batch_s = 300,   reduce_batch_by = 3, variable_name  = "PRECIP_media_espacial", scale = 500)


```

**Post procesamiento de .csv**

El cÃ³digo a continuaciÃ³n lee todos los .csv de una propiedad (por ejemplo, "slope"),los combina en un solo data.frame, lo guarda como OUT_slope_combinado.csv (o OUT\_<propiedad>\_combinado.csv segÃºn corresponda), y lo sube automÃ¡ticamente al repositorio del proyecto, usando el paquete googledrive.

```{r reubicar_googledrive}

# Copia local de archivos combinados para reproducibilidad offline
combinar_y_subir_csv <- function(propiedad,
                                 carpeta_drive_id_origen = "17yxwhlpgL4EG8inI5u8Nwi08wOrnhJiM",  # GEE_exports
                                 carpeta_drive_id_destino = "1qJ5S25TZaFWzueNhx1M4Gr3P8JYWKGeU",  # Proyecto
                                 carpeta_temporal = "tmp_csv") {

  # Crea carpeta temporal local si no existe
  if (!dir.exists(carpeta_temporal)) {
    dir.create(carpeta_temporal)
  }

  # Listar archivos en Google Drive (solo .csv con prefijo exacto)
  archivos_drive <- googledrive::drive_ls(
    path = as_id(carpeta_drive_id_origen),
    pattern = glue::glue("^{propiedad}_.*\\.csv$")
  ) |>
    dplyr::filter(stringr::str_ends(name, ".csv"))

  if (nrow(archivos_drive) == 0) {
    stop(glue::glue("No se encontraron archivos CSV para la propiedad '{propiedad}' en GEE_exports."))
  }

  message(glue::glue("ðŸ“¥ Descargando {nrow(archivos_drive)} archivos CSV para '{propiedad}'..."))

  # Descargar archivos al directorio temporal
  purrr::walk2(
    archivos_drive$name,
    archivos_drive$id,
    ~ googledrive::drive_download(
      file = as_id(.y),
      path = file.path(carpeta_temporal, .x),
      overwrite = TRUE
    )
  )

  # Leer y combinar
  archivos_locales <- list.files(path = carpeta_temporal,
                                 pattern = paste0("^", propiedad, "_.*\\.csv$"),
                                 full.names = TRUE)

  combinado <- purrr::map_dfr(archivos_locales, readr::read_csv, show_col_types = FALSE)

  # Escribir archivo combinado
  nombre_salida <- paste0("OUT_", propiedad, "_combinado.csv")
  ruta_salida <- file.path(carpeta_temporal, nombre_salida)
  readr::write_csv(combinado, ruta_salida)

  # Subir a carpeta final de proyecto en Drive
  archivo_subido <- googledrive::drive_upload(
    media = ruta_salida,
    path = as_id(carpeta_drive_id_destino),
    name = nombre_salida,
    overwrite = TRUE
  )

  message(glue::glue("âœ… Archivo combinado subido: {archivo_subido$name} (ID: {archivo_subido$id})"))

  # Limpieza automÃ¡tica
  unlink(carpeta_temporal, recursive = TRUE)
  message("ðŸ§¹ Archivos temporales eliminados.")
}

```

Aplica la funciÃ³n para las covariables. Esto se corre solo una vez, para combinar los csv por lotes.

```{r aplica_funcion_combinacion}

#combinar_y_subir_csv("DEM")
#combinar_y_subir_csv("SLOPE")
#combinar_y_subir_csv("LST_cv_temporal")
#combinar_y_subir_csv("LST_media_espacial") 
#combinar_y_subir_csv("PRECIP_cv_temporal")
#combinar_y_subir_csv("PRECIP_media_espacial") 

```

En este bloque cargamos las tablas .csv exportadas desde Google Earth Engine y las convertimos en objetos sf que conservan la geometrÃ­a de cada Unidad CartogrÃ¡fica de Suelo (UCS). Para cada producto (DEM, pendiente, LST, precipitaciÃ³n) se generan de forma sistemÃ¡tica cinco conjuntos de variables:

1.  Media (p. ej. dem_mean).

2.  Coeficiente de variaciÃ³n CV=Ïƒ /âˆ£Î¼âˆ£+Îµ

Se usa el valor absoluto de la media para que el CV siga midiendo variabilidad aunque existan medias negativas (caso DEM y pendiente) y se aÃ±ade un pequeÃ±o Îµ=10âˆ’6 para evitar divisiones por cero.

3.  CV densificado (CV / Ãrea).

4.  Transformaciones logâ‚â‚€ â†’ permiten visualizar colas largas y utilizar escalas continuas.

5.  Estandarizaciones z â†’ Ãºtiles en los modelos (centro = 0, varianza = 1).

Excepto DEM y pendiente (que pueden tener medias â‰¤ 0), los demÃ¡s promedios son positivos; por tanto, no requieren el ajuste âˆ£Î¼âˆ£

```{r carga_covariables}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 0 Â· Ajuste de precisiÃ³n para divisiones seguras
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eps <- 1e-6                         # Îµ evita CV = Ïƒ/0
safe_log10 <- function(x) log10(pmax(x, eps))

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 1 Â· DEM (media & CV espacial)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
dem_cv <- readr::read_csv(
  here::here("Data/OUT_covars_csv/OUT_DEM_combinado.csv"),
  show_col_types = FALSE
)

covars_dem <- st_as_sf(
  data.frame(dem_cv, geometry = geojson_sf(dem_cv$.geo)), crs = 4326
) |>
  dplyr::rename(dem_mean = mean) |>
  dplyr::mutate(
    dem_cv          = stdDev / pmax(abs(dem_mean), eps),
    log_dem_cv      = safe_log10(dem_cv),
    dem_cv_dens     = dem_cv / AREA_HA,
    log_dem_cv_dens = safe_log10(dem_cv_dens),
    across(c(dem_cv, log_dem_cv, dem_cv_dens, log_dem_cv_dens, dem_mean),
           ~ scale(.x)[, 1], .names = "{.col}_z")
  ) |>
  dplyr::select(-.geo, -stdDev, -system.index)   

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 2 Â· SLOPE (media & CV espacial)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
slope_cv <- readr::read_csv(
  here::here("Data/OUT_covars_csv/OUT_SLOPE_combinado.csv"),
  show_col_types = FALSE
)

covars_slope <- st_as_sf(
  data.frame(slope_cv, geometry = geojson_sf(slope_cv$.geo)), crs = 4326
) |>
  dplyr::rename(slope_mean = mean) |>
  dplyr::mutate(
    slope_cv          = stdDev / pmax(abs(slope_mean), eps),
    log_slope_cv      = safe_log10(slope_cv),
    slope_cv_dens     = slope_cv / AREA_HA,
    log_slope_cv_dens = safe_log10(slope_cv_dens),
    across(c(slope_cv, log_slope_cv, slope_cv_dens, log_slope_cv_dens, slope_mean),
           ~ scale(.x)[, 1], .names = "{.col}_z")
  ) |>
  dplyr::select(-.geo, -stdDev, -system.index)   

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 3 Â· LST media espacial (2013-2023)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
lst_media_esp <- readr::read_csv(
  here::here("Data/OUT_covars_csv/OUT_LST_media_espacial_combinado.csv"),
  show_col_types = FALSE
)

covars_lst_media <- st_as_sf(
  data.frame(lst_media_esp, geometry = geojson_sf(lst_media_esp$.geo)), crs = 4326
) |>
  dplyr::rename(lst_mean = mean) |>
  dplyr::mutate(
    log_lst_mean        = safe_log10(lst_mean),
    lst_mean_dens       = lst_mean / AREA_HA,
    log_lst_mean_dens   = safe_log10(lst_mean_dens),
    across(c(lst_mean, log_lst_mean, lst_mean_dens, log_lst_mean_dens),
           ~ scale(.x)[, 1], .names = "{.col}_z")
  ) |>
  dplyr::select(-.geo, -stdDev, -system.index)   

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 4 Â· LST CV temporal (2013-2023)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
lst_cv_temp <- readr::read_csv(
  here::here("Data/OUT_covars_csv/OUT_LST_cv_temporal_combinado.csv"),
  show_col_types = FALSE
)

covars_lst_cv_temp <- st_as_sf(
  data.frame(lst_cv_temp, geometry = geojson_sf(lst_cv_temp$.geo)), crs = 4326
) |>
  dplyr::rename(lst_cv_temp = mean) |>
  dplyr::mutate(
    log_lst_cv_temp        = safe_log10(lst_cv_temp),
    lst_cv_temp_dens       = lst_cv_temp / AREA_HA,
    log_lst_cv_temp_dens   = safe_log10(lst_cv_temp_dens),
    across(c(lst_cv_temp, log_lst_cv_temp, lst_cv_temp_dens, log_lst_cv_temp_dens),
           ~ scale(.x)[, 1], .names = "{.col}_z")
  ) |>
  dplyr::select(-.geo, -stdDev, -system.index)   

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 5 Â· PRECIP CV temporal  &  6 Â· PRECIP media espacial (idÃ©ntica lÃ³gica)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Precip cv temporal
precip_cv_temp <- readr::read_csv(
  here::here("Data/OUT_covars_csv/OUT_PRECIP_cv_temporal_combinado.csv"),
  show_col_types = FALSE
)

covars_precip_cv_temp <- st_as_sf(
  data.frame(precip_cv_temp, geometry = geojson_sf(precip_cv_temp$.geo)), crs = 4326
) |>
  dplyr::rename(precip_cv_temp = mean) |>
  dplyr::mutate(
    log_precip_cv_temp        = safe_log10(precip_cv_temp),
    precip_cv_temp_dens       = precip_cv_temp / AREA_HA,
    log_precip_cv_temp_dens   = safe_log10(precip_cv_temp_dens),
    across(c(precip_cv_temp, log_precip_cv_temp, precip_cv_temp_dens, log_precip_cv_temp_dens),
           ~ scale(.x)[, 1], .names = "{.col}_z")
  ) |>
  dplyr::select(-.geo, -stdDev, -system.index)   


# Precip media espacial
precip_media_esp <- readr::read_csv(
  here::here("Data/OUT_covars_csv/OUT_PRECIP_media_espacial_combinado.csv"),
  show_col_types = FALSE
)

covars_precip_media <- st_as_sf(
  data.frame(precip_media_esp, geometry = geojson_sf(precip_media_esp$.geo)), crs = 4326
) |>
  dplyr::rename(precip_mean = mean) |>
  dplyr::mutate(
    log_precip_mean        = safe_log10(precip_mean),
    precip_mean_dens       = precip_mean / AREA_HA,
    log_precip_mean_dens   = safe_log10(precip_mean_dens),
    across(c(precip_mean, log_precip_mean, precip_mean_dens, log_precip_mean_dens),
           ~ scale(.x)[, 1], .names = "{.col}_z")
  ) |>
  dplyr::select(-.geo, -stdDev, -system.index)   


```

## 4. EDA covariables

Ya que `dem_cv_sf`, `slope_cv_sf` y `ucs_rao_sf` comparten `id_creado` como identificador Ãºnico, se hace un `left_join` sucesivo para combinar sus mÃ©tricas

```{r}

# Unir a la tabla base
modelo_df <- ucs_rao_sf |>
  left_join(covars_dem |> st_drop_geometry(),        by = c("id_creado", "AREA_HA", "UCSuelo")) |>
  left_join(covars_slope |> st_drop_geometry(),      by = c("id_creado", "AREA_HA", "UCSuelo")) |>
  left_join(covars_lst_cv_temp  |> st_drop_geometry(),    by = c("id_creado", "AREA_HA", "UCSuelo")) |>
  left_join(covars_lst_media |> st_drop_geometry(),    by = c("id_creado", "AREA_HA", "UCSuelo")) |>
  left_join(covars_precip_cv_temp |> st_drop_geometry(),  by = c("id_creado", "AREA_HA", "UCSuelo")) |>
  left_join(covars_precip_media |> st_drop_geometry(), by = c("id_creado", "AREA_HA", "UCSuelo"))

```

### 4.1 Distribuciones

Se verifican visualmente las distribuciones de la magnitud y coeficiente de variaciÃ³n de las covariables. Debido a que el coeficiente de variaciÃ³n

```{r}

# FunciÃ³n general para histogramas
common_hist <- function(data, var, title, xlab){
  ggplot(dplyr::filter(data, is.finite({{ var }})), aes({{ var }})) +
    ggdist::stat_histinterval(fill = "#56B4E9", colour = "black") +  # sin â€œbinsâ€
    geom_density(aes(y = after_stat(scaled)), colour = "#FFD700",
                 linewidth = 0.8) +
    labs(title = title, x = xlab, y = "Frecuencia") +
    theme_minimal(base_size = 12)
}

# Magnitudes ---------------------------------------------------------------
p_dem_mean   <- common_hist(modelo_df, dem_mean,   "ElevaciÃ³n media",           "m")
p_slope_mean <- common_hist(modelo_df, slope_mean, "Pendiente media",           "Â°")
p_lst_mean   <- common_hist(modelo_df, lst_mean,   "LST media",                "Â°C")
p_prec_mean  <- common_hist(modelo_df, precip_mean,"Precip. media mensual","mmÂ·mesâ»Â¹")

# log(CV) ------------------------------------------------------------------
p_dem_log_cv   <- common_hist(modelo_df, log_dem_cv,
                              expression(log[10]*"CV DEM"),          expression(log[10]*"CV"))
p_slope_log_cv <- common_hist(modelo_df, log_slope_cv,
                              expression(log[10]*"CV pendiente"),    expression(log[10]*"CV"))
p_lst_log_cv   <- common_hist(modelo_df, log_lst_cv_temp,
                              expression(log[10]*"CV LST"),          expression(log[10]*"CV"))
p_prec_log_cv  <- common_hist(modelo_df, log_precip_cv_temp,
                              expression(log[10]*"CV precipitaciÃ³n"),expression(log[10]*"CV"))

# log(CV dens) -------------------------------------------------------------
p_dem_log_cvd   <- common_hist(modelo_df, log_dem_cv_dens,
                               expression(log[10]*"CVdens DEM"),          expression(log[10]*"CVdens"))
p_slope_log_cvd <- common_hist(modelo_df, log_slope_cv_dens,
                               expression(log[10]*"CVdens pendiente"),    expression(log[10]*"CVdens"))
p_lst_log_cvd   <- common_hist(modelo_df, log_lst_cv_temp_dens,
                               expression(log[10]*"CVdens LST"),          expression(log[10]*"CVdens"))
p_prec_log_cvd  <- common_hist(modelo_df, log_precip_cv_temp_dens,
                               expression(log[10]*"CVdens precipitaciÃ³n"),expression(log[10]*"CVdens"))

# Mosaico 4Ã—3 --------------------------------------------------------------

p_mosaico_hist <- (
  p_dem_mean  | p_slope_mean  | p_lst_mean  | p_prec_mean) /
  (p_dem_log_cv | p_slope_log_cv | p_lst_log_cv | p_prec_log_cv) /
  (p_dem_log_cvd| p_slope_log_cvd| p_lst_log_cvd| p_prec_log_cvd)

# Muestra en visor
p_mosaico_hist

# Guardar si se desea
ggsave(
  here::here("Figures", "mosaico_hist_covariables.png"),
  plot   = p_mosaico_hist,
  width  = 12, height = 9, dpi = 350
)

```

### 4.2 VisualizaciÃ³n espacial de las covariables

Se visualizan las covariables rasterizadas. Las escalas de colores se reflejan asociaciones simbÃ³licas con los procesos fÃ­sicos que representan (e.g. rojo, mayor temperatura, azul, mayor precipitaciÃ³n). La escala de mapas de coeficientes de varaiciÃ³n representa n

```{r}

# DefiniciÃ³n de colores --------------------------------------------------------

# Paletas de magnitud  (10 pasos â†’ se interpolan en la escala) 

pal_dem   <- paletteer::paletteer_c("grDevices::terrain.colors", n = 10)
pal_slope <- paletteer::paletteer_c("grDevices::Temps",          n = 10)
pal_lst   <- paletteer::paletteer_c("ggthemes::Red-Gold",        n = 10)
pal_prec  <- paletteer::paletteer_c("grDevices::Earth",          n = 10) # "grDevices::Roma"


# Gradientes monocromÃ¡ticos  blanco â†’ color_extremo  (para los CV PUROS)

mono_pal <- function(col_hex, n = 100) colorRampPalette(c("#ffffff", col_hex))(n)

pal_dem_cv   <- mono_pal(head(pal_dem, 1))   # â† ahora usa el 1er color
pal_slope_cv <- mono_pal(tail(pal_slope, 1))
pal_lst_cv   <- mono_pal(tail(pal_lst,   1))
pal_prec_cv  <- mono_pal(tail(pal_prec,  1))


# FunciÃ³n genÃ©rica para mapas --------------------------------------------------

# ARGUMENTOS
#   data   : data.frame / tibble con geometrÃ­a sf.
#   var    : nombre de la columna a mapear (tidy-eval, sin comillas).
#   pal    : vector de colores hex (paleta continua ya generada).
#   titulo : texto para el tÃ­tulo del mapa.

map_mag <- function(data, var, pal, titulo, leyenda){
  ggplot(data) +
    geom_sf(aes(fill = {{ var }}), colour = NA) +
    scale_fill_gradientn(
      colours = pal, 
      na.value = "white",
      guide   = guide_colourbar(
        direction      = "vertical",
        barwidth       = unit(0.25, "cm"),
        barheight      = unit(2.5,  "cm"),
        title.position = "top"
        ),
      name = leyenda
      ) +
    labs(title = titulo) +
    theme_minimal() + 
    theme(legend.justification = c("right", "top"))
}

map_cv <- function(data, var, pal, titulo){
  ggplot(data |> dplyr::filter({{ var }} > 0)) + #Descarta valores cero o negativos antes de transformar
    geom_sf(aes(fill = {{ var }}), colour = NA) +
    scale_fill_gradientn(
      colours = pal,
      trans   = "log10", # usa escala log-10 para contrastar valores bajos y altos de CV
      breaks  = scales::trans_breaks("log10", function(x) 10^x),
      labels  = scales::label_number(accuracy = .001),
      na.value = "white",
      guide   = guide_colourbar(
        direction      = "vertical",
        barwidth       = unit(0.25, "cm"),
        barheight      = unit(2.5,  "cm"),
        title.position = "top"
        ),
      name    = "CV"
    ) +
    labs(title = titulo) +
    theme_minimal() + 
    theme(legend.justification = c("right", "top"))
}

##############################################################################

# GeneraciÃ³n de mapas ----------------------------------------------------------

# Mapas de magnitud

p_dem_mean   <- map_mag(modelo_df, dem_mean,   pal_dem,   "Media de DEM (m)",               "m")
p_slope_mean <- map_mag(modelo_df, slope_mean, pal_slope, "Media de pendiente (Â°)",         "Â°")
p_lst_mean   <- map_mag(modelo_df, lst_mean,  pal_lst,   "Media de LST (Â°C)",              "Â°C")
p_prec_mean  <- map_mag(modelo_df, precip_mean,pal_prec, "Media de precipitaciÃ³n (mmÂ·mesâ»Â¹)","mm")


# Mapas de variabilidad  (CV, NO densificado)

p_dem_cv   <- map_cv(modelo_df, dem_cv,        pal_dem_cv,   "CV de DEM")
p_slope_cv <- map_cv(modelo_df, slope_cv,      pal_slope_cv, "CV de pendiente")
p_lst_cv   <- map_cv(modelo_df, lst_cv_temp,   pal_lst_cv,   "CV de LST")
p_prec_cv  <- map_cv(modelo_df, precip_cv_temp,pal_prec_cv,  "CV de precipitaciÃ³n")


# ComposiciÃ³n de figura -----------------------------------------------------------

# Mosaico 4 Ã— 2   (fila superior = magnitud, inferior = CV)

p_mosaico <- (p_dem_mean | p_slope_mean | p_lst_mean | p_prec_mean) /
             (p_dem_cv   | p_slope_cv   | p_lst_cv   | p_prec_cv  )

ggsave(
  here::here("Figures", "mosaico_mapa_covariables.png"),
  plot   = p_mosaico,
  width  = 12, height = 6, dpi = 350
)

```
