---
title: "Análisis de exploratorio de covariables"
author: "Carlos M. Guío Blanco"
format: html
editor: visual
---

Este cuaderno implementa en un solo flujo la conexión de R con Google Earth Engine para derivar atributos geomorfométricos e hidroclimáticos satelitales, cuantificar la heterogeneidad interna de estos atributos para cada Unidad Cartográfica de Suelo (UCS) mediante el coeficiente de variación,

**Estructura del script**

1.  **Inicialización**: carga de librerías y autenticación en Earth Engine.
2.  **Carga de vectores**: UCS armonizadas para área de estudio (Andina, Caribe, Pacífico).
3.  **Derivación de rasters**: extracción y cálculo de elevacón, pendiente, curvatura vertical (TAGEE), temperatura superficial (Landsat) y VH/VV (Sentinel 1).
4.  **Extracción de métricas**: media, desviación estándar y CV por polígono para cada variable.

```{r configuracion}

#Para exportar como .R plano
# knitr::purl('03_analisis_eda_covariables.qmd')

if (!"pacman" %in% installed.packages()) install.packages("pacman")
pacman::p_load(
  here,        # rutas relativas del proyecto
  sf,          # lectura y manipulación de objetos espaciales vectoriales
  httr,        # peticiones HTTP REST (consulta servicio Mapa Geológico)
  geojsonsf,   # GeoJSON ↔ sf rápido (geojson_sf)
  dplyr,       # gramática de datos: mutate, select, joins
  tidyr,       # ✗ (no usado; pivot, unnest…)
  stringr,     # utilidades de texto y regex
  purrr,       # programación funcional: map*, walk*
  broom,       # ✗ (no usado; tidy de modelos)
  readr,       # lectura/escritura rápida de CSV
  ggdist,      # distribuciones y ‘raincloud’/histinterval
  scales,      # transformaciones y breaks de ejes
  ggplot2,     # visualización de datos
  paletteer,    # paletas de colores
  patchwork,   # combinación de gráficos ggplot
  wesanderson, # paletas continuas y discretas
  qs           # ✗ (no usado; serialización rápida .qs)
)

#Paleta de colores
pal <- wes_palette("Zissou1", 100, type = "continuous")

# Ajusta tamaño de letra para todo e lscript
theme(base_size = 14)

# Selección entorno ya existente antes de cualquier llamado que use Python
reticulate::use_condaenv("rgee_py", required = TRUE)

## Librerías que usan Python 
library(reticulate)
library(rgee)
library(googledrive)

# ==== Autenticación y backend Python ====
# Se fuerzan credenciales limpias para evitar colisiones de proyectos GEE entre sesiones
ee_clean_user_credentials()      # Limpia credenciales de GEE
ee_clean_pyenv()           # Limpia variables de entorno de reticulate
reticulate::py_run_string("import ee; ee.Authenticate()")
reticulate::py_run_string("import ee; ee.Initialize(project='even-electron-461718-g2')") #cuenta gmail propia
#reticulate::py_run_string("import ee; ee.Initialize(project='optimal-signer-459113-i1')") #cuenta UNAL

# === Autenticación Google Drive ===
googledrive::drive_auth()
```

Prueba de funcionamiento de rgee

```{r verifica_configuracion}

# Se consultan datos de DEM
img <- ee$Image("USGS/SRTMGL1_003")

#Consulta que propiedades están disponibles
img$propertyNames()$getInfo()

# Consultar una propiedad específica, e.g. keywords
img$get("keywords")$getInfo()
```

## 1. Carga de datos vectoriales

### 1.1 Carga de datos de pedodiversidad de UCS

Los datos producto del procesamiento de Rao, se han subido a un repositorio de Zenodo. Estos se utilizan acá para derivar las covariables a nivel de polígono de UCS. Por tal razón, solo se importan variables que no tengan NAs.

```{r carga_pedodiversidad}

# Corre script externo para cargar
source(here::here("Scripts", "00_funcion_carga_ucs_procesadas_qs.R"), encoding = "UTF-8")

# Asignación de id único para cada polígono
ucs_rao_sf <- ucs_rao_sf |> 
  sf::st_make_valid() |> #valida geometrias problemáticas
  dplyr::select(id_creado, UCSuelo, AREA_HA) 

ucs_rao_sf <- ucs_rao_sf[!st_is_empty(ucs_rao_sf), ]

#Se verifica visulalmente
ggplot(data = ucs_rao_sf) +
  geom_sf(aes(fill = UCSuelo), color = NA) +  
  theme_void() +                             
  theme(legend.position = "none") 
```

### 1.2 Carga de datos de unidades geológicas SGC

Las unidades geológicas son un insumo que se utilizará posteriormente para los modelos jerárquicos. Estos datos se cargan via API del servicio de ArcGIS que usa el Servicio Geológico Colombiano. No requieren token.

```{r geologia_descarga_reclasificacion}

# Se desagrega la url básica en sus componentes
url <- httr::parse_url("https://srvags.sgc.gov.co/arcgis/rest/services/Mapa_Geologico_Colombia/Mapa_Geologico_Colombia_V2023/MapServer")

layer_id <- "733"

url$path <- paste(url$path, layer_id, "query", sep = "/")

# Se agregan componentes a la URL para solicitud de información
url$query <- list(where = "1=1", # para recuperar todos los features
                  outFields = "*", #para recuperar todos los campos
                  returnGeometry = "true", #retorna geometrias
                  f = "geojson") #retorna formato geojson

# Se construye la url
url_solicitud <- httr::build_url(url)

# Para recuperar los datos espaciales se usa la librería sf
respuesta <- httr::GET(url_solicitud)

#Se examina la respuesta
print(respuesta)

# Descarga del mapa geológico 1 : 500 000 y clasificación de unidades por era (más joven)
geo_sf_wgs84 <- sf::st_read(url_solicitud) |>
  sf::st_make_valid() |>
  mutate(
    # LIMPIEZA -----------------------------------------------------------------
    edad_limpia = Edad %>% 
      str_replace_all("\\?", "") %>%    # quita “?”
      str_trim() %>%                    # quita espacios extremos
      str_squish(),                     # colapsa espacios múltiples
    
    # RECLASIFICACIÓN POR ERA (la MÁS JOVEN domina) ----------------------------
    era_geo = case_when(
      # 1) CENOZOICO  ----------------------------------------------------------
      str_detect(edad_limpia, regex(
        "paleoceno|eoceno|oligoceno|mioceno|plioceno|pleistoceno|holoceno|
         aquitaniano|burdigaliano|langhiano|serravaliano|tortoniano|messiniano|
         zancliano|rupeliano|thanetiano|lutetiano|bartoniano|priaboniano|
         selandiano|daniense|chattiano",
        ignore_case = TRUE)
      ) ~ "Cenozoico",
      
      # 2) MESOZOICO  ----------------------------------------------------------
      str_detect(edad_limpia, regex(
        "triásico|jurásico|cretácico|berriasiano|valanginiano|barremiano|
         aptiano|albiano|cenomaniano|turoniano|coniaciano|santoniano|
         campaniano|maastrichtiano",
        ignore_case = TRUE)
      ) ~ "Mesozoico",
      
      # 3) PALEOZOICO ----------------------------------------------------------
      str_detect(edad_limpia, regex(
        "cámbrico|ordovícico|silúrico|devónico|mississipiano|pridoliano|
         carbonífero|pennsylvaniano|pérmico",
        ignore_case = TRUE)
      ) ~ "Paleozoico",
      
      # 4) PROTEROZOICO --------------------------------------------------------
      str_detect(edad_limpia, regex(
        "sideriano|rhyaciano|orosiriano|statheriano|calymmiano|ectasiano|
         steniano|toniano|criogénico|ediacariano|mesoproterozoico|
         neoproterozoico|proterozoico",
        ignore_case = TRUE)
      ) ~ "Proterozoico",
      
      # 5) SIN DATO ------------------------------------------------------------
      TRUE ~ "Sin_dato"
    )
  ) |>
  select(descripcion_geo = Descripcion, era_geo)



#Se visualizan datos geográficamente (edad, sin leyenda)
p_mapa_geo <- ggplot2::ggplot(geo_sf_wgs84) +
  geom_sf(aes(fill = era_geo), color = NA) +
  scale_fill_manual(
    name   = "Era geológica",                         # (1) título de la leyenda
    breaks = c("Cenozoico", "Mesozoico",              # (3) orden joven → antiguo
               "Paleozoico", "Proterozoico", "Sin_dato"),
    values = c(                                       # (2) colores por categoría
      Cenozoico   = "#f8ea1e",
      Mesozoico   = "#5bc5ea",
      Paleozoico  = "#a9c6a8",
      Proterozoico= "#ea5173",
      Sin_dato    = "gray90"
    ),
    drop = FALSE                                      # muestra todas las clases aunque falten
  ) +
  theme_minimal()

p_mapa_geo
```

### 1.3 Armonización con GEE

Se definen parámetros de extensión, CRS y resolución para armonizar los datos de GEE con con los datos de pedodiversidad de UCS. Para la definición del área de recorte se toma un buffer sobre el objeto de sf. Esto amortiguará posteriormente efectos de borde en el cálculo de la diversidad. No se recomienda enviar el objeto completo y hacer el buffer en GEE, dado que el envío de un ubjeto con numerosos multipoligonos (como es el caso) es prohibitivo en GEE. Los envios no pueden superar 10MB por tarea.

```{r transforma_crs}

# Transforma a crs 4326 antes de pasarlo a GEE
ucs_sf_4326 <- st_transform(ucs_rao_sf, 4326)


# #Extrae bounding boxdel área del subconjunto
bb_sf_4326 <- st_bbox(ucs_sf_4326)

```

Crea geometria de bbox en GEE usando las coordenadas del bbox creado en R con sf.

```{r  tansform_ee}

# Convertir a rectángulo de Earth Engine
bbox_ee <- ee$Geometry$Rectangle(
  coords = list(
    bb_sf_4326["xmin"], 
    bb_sf_4326["ymin"], 
    bb_sf_4326["xmax"], 
    bb_sf_4326["ymax"]
    ),
  geodesic = FALSE
)

```

## 2. Derivación de variables raster en GEE

A continuación se calculan los índices geomorfométricos e hidroclimáticos. Primero se declaran los objetos raster y se visualizan para verificar. Todos los raster se visualizan en su resolución original.

### 2.1 DEM

Se define el objeto raster de elevación y se visualiza su extensión.

```{r extraccion_dem}

# Carga y suavizado del DEM SRTM 30 m
dem_clip <- ee$Image("USGS/SRTMGL1_003")$clip(bbox_ee)

# Visualiza en el visor antes de exportar (verifica recorte)
Map$setCenter(lon = -74, lat = 4, zoom = 5)
Map$addLayer(
  dem_clip,
  visParams = list(min = 0, max = 3000,
                   palette = viridis::viridis(10)), 
  name = "DEM SRTM (nativo 30m)"
  )

```

### 2.2 Pendiente

```{r extraccion_pendiente}

# Procesamiento de pendiente (slope) a partir del SRTM
slope_clip <- ee$Terrain$
  slope(ee$Image("USGS/SRTMGL1_003"))$
  clip(bbox_ee)$
  rename("slope_deg")  # valores ya están en grados

# Visualiza en el visor antes de exportar (verifica recorte)
Map$setCenter(lon = -74, lat = 4, zoom = 5)
Map$addLayer(
  slope_clip,
  visParams = list(min = 0, max = 50,
                   palette = viridis::viridis(10)), 
  name = "Pendiente SRTM (nativo 30m)"
  )
```

### 2.3 Curvatura vertical

A continuación se invoca la función terrainAnalysis del módulo TAGEE en GEE. Al hacerlo se calcula en la nube de Earth Engine un conjunto completo de atributos geomorfométricos a partir del DEM de entrada.TAGEE utliza un DEM base de ...

Cada vez que se llama a py_install() o importa un nuevo módulo con reticulate::import(), reticulate reinicia o “reconfigure” el intérprete Python, y por tanto se debe repetir la inicialización de Earth Engine.

```{r}

# Bloque único de setup (solo la primera vez)
if (!py_module_available("tagee")) {
  py_install(c("tagee","ee_extra","regex","jsbeautifier"),
             envname="rgee_py", pip=TRUE)
}
tagee <- import("tagee",    convert = FALSE)
eeextra <- import("ee_extra", convert = FALSE)

reticulate::py_run_string("import ee; ee.Initialize(project='even-electron-461718-g2')")

# Ejecuta el análisis de terreno (devuelve un ee$Image con múltiples bandas)
dem_attr <- tagee$terrainAnalysis(dem_clip)

# Extrae la banda de Curvatura Vertical
vc_clip <- dem_attr$select("VerticalCurvature")$clip(bbox_ee)


Map$setCenter(lon = -74, lat = 4, zoom = 5)
Map$addLayer(
  vc_clip,
  visParams = list(
    min     = -0.00005,
    max     = +0.00005,
    palette = viridis::viridis(5)
  ),
  name = "Curvatura vertical (±0.00005)"
)

```

### 2.4 Temperatura superficial

La temperatura superficial se obtiene del producto MODIS MOD11A2 v6.1, un compuesto de 8 días a 1 km de resolución generado a partir de las observaciones diurnas del sensor térmico de Terra. Para garantizar una cobertura homogénea, se emplea toda la serie de 2013 – 2023 (≈ 460 compuestos por píxel). A partir de esta colección se derivan dos conjuntos de datos recortados al área de estudio (bbox):

-   Media espacial decenal – promedio de la LST (°C) de los 460 compuestos, que describe la temperatura superficial promedio del último decenio.

-   Coeficiente de variación temporal – relación entre la desviación estándar y la media (σ / μ) de la misma serie, indicador de cuán variable ha sido la temperatura en cada píxel a lo largo de diez años.

Ambas capas se promedian después dentro de cada polígono UCS para incorporarlas como covariables térmicas en los modelos de pedodiversidad.

**MODIS LST — Media espacial (8-días, 1 km)**

En este bloque cargamos el producto MOD11A2 v6.1 (compuesto de 8 días, 1 km, temperatura superficial diurna). Cada compuesto ya promedia las observaciones diarias “claras” dentro de su intervalo. Al convertir todos los compuestos de 2013-2023 a °C y aplicar mean(), obtenemos para cada píxel la LST diurna media decenal. Esta capa resume la temperatura superficial típica del último decenio y se usará como indicador térmico basal para cada polígono de suelos.

```{r}


# =============================================================================
# Colección MODIS MOD11A2 (8-días, 1 km) convertida a °C
# =============================================================================
modis_collection <- ee$ImageCollection("MODIS/061/MOD11A2")$
  filterBounds(bbox_ee)$              # descarta las imágenes cuyo footprint no toca tu bbox_ee
  filterDate("2013-01-01", "2023-01-01")$
  map(function(img) {
    img$select("LST_Day_1km")$        # banda de temperatura diurna
      multiply(0.02)$                 # factor de escala
      subtract(273.15)$               # K → °C
      rename("lst_celsius")$
      clip(bbox_ee)                   # recorte geométrico
  })

# ── MEDIA ESPACIAL POR PÍXEL ────────────────────────────────────────────────
modis_media_espacial <- modis_collection$mean()$rename("modis_media_espacial")

# Verificación visual en el visor de Earth Engine
Map$setCenter(lon = -74, lat = 4, zoom = 5)
Map$addLayer(
  modis_media_espacial, 
  list(min = 10, max = 45, palette = c("blue","white","red")),
  "MODIS LST media (°C)"
)



```

**MODIS LST — Coeficiente de variación temporal (8-días, 1 km)**

Partiendo de la misma colección MOD11A2 (2013-2023) derivamos primero la media y la desviación estándar de la serie de 8 días para cada píxel; su cociente (σ / μ) nos da el coeficiente de variación temporal (CV). Este mapa refleja qué tan inestable es la temperatura superficial a lo largo de los 10 años: valores altos indican variabilidad térmica marcada, valores bajos un régimen más estable.

```{r}

# =============================================================================
# Colección MODIS MOD11A2 (8-días, 1 km) convertida a °C
# =============================================================================
modis_collection <- ee$ImageCollection("MODIS/061/MOD11A2")$
  filterBounds(bbox_ee)$              # descarta las imágenes cuyo footprint no toca tu bbox_ee
  filterDate("2013-01-01", "2023-01-01")$
  map(function(img) {
    img$select("LST_Day_1km")$        # banda de temperatura diurna
      multiply(0.02)$                 # factor de escala
      subtract(273.15)$               # K → °C
      rename("lst_celsius")$
      clip(bbox_ee)                   # recorte geométrico
  })

# ── CV TEMPORAL POR PÍXEL ────────────────────────────────────────────────
modis_temp_mean <- modis_collection$mean()$rename("modis_temp_mean")
modis_temp_sd   <- modis_collection$reduce(ee$Reducer$stdDev())$rename("modis_temp_sd")
modis_temp_cv   <- modis_temp_sd$divide(modis_temp_mean)$rename("modis_temp_cv")

# Verificación visual en el visor de Earth Engine
Map$setCenter(lon = -74, lat = 4, zoom = 5)
Map$addLayer(
  modis_temp_cv, 
  list(min = 0, max = 0.15, palette = c("blue","orange","red")),
  "MODIS LST CV temporal"
)

```

### 2.5 Precipitación

La precipitación se extrae del producto CHIRPS v2.1 Daily (Climate Hazards Group InfraRed Precipitation with Station data). CHIRPS combina estimaciones satelitales e información de pluviómetros en una rejilla de 0,05 ° (\~ 5,5 km), con cobertura cuasi-global desde 1981. Para asegurar una serie homogénea usamos todo el intervalo 2013 – 2023 (datos diarios).

**Precipitación media espacial (CHIRPS, 2013-2023)**

A partir de la misma serie diaria de CHIRPS se agrega primero a **totales mensuales** y luego se promedia esos 120 meses (2013-2023). El resultado es, para cada píxel, la **precipitación media mensual acumulada** (mm · mes⁻¹) representativa de la última década. Al reducir esta capa sobre los polígonos de suelos obtenemos, para cada UCS, un indicador directo de disponibilidad hídrica promedio ‒en la misma unidad temporal del CV mensual‒ que se incorporará como covariable en los modelos de pedodiversidad.

```{r}

# (1) Colección diaria recortada al bbox
chirps_daily <- ee$ImageCollection("UCSB-CHG/CHIRPS/DAILY")$
  filterBounds(bbox_ee)$
  filterDate("2013-01-01", "2023-01-01")

# (2) Agregación mensual  (mm por mes)
chirps_monthly_ic <- ee$ImageCollection(
  ee$List$sequence(2013, 2023)$map(ee_utils_pyfunc(function(y) {
    ee$List$sequence(1, 12)$map(ee_utils_pyfunc(function(m) {
      start <- ee$Date$fromYMD(y, m, 1)
      end   <- start$advance(1, "month")
      chirps_daily$
        filterDate(start, end)$
        sum()$                      # mm del mes
        clip(bbox_ee)$
        set("system:time_start", start)
    }))
  }))$flatten()
)

# (3) Media mensual (mm · mes⁻¹) por píxel en 2013–2023
precip_media_espacial <- chirps_monthly_ic$
  mean()$
  rename("precip_media_espacial")$
  clip(bbox_ee)

# (4) Vista rápida en el visor de Earth Engine
Map$setCenter(lon = -74, lat = 4, zoom = 5)
Map$addLayer(
  precip_media_espacial,
  list(min = 0, max = 800, palette = c("blue", "white", "red")),
  "CHIRPS · media mensual (mm/mes)"
)

```

**CV temporal de la precipitación (CHIRPS, 2013-2023)**

Para cuantificar cuán irregular es la lluvia a lo largo del año, tomamos la serie diaria CHIRPS (0,05° ≈ 5 km) y la agregamos a totales mensuales por píxel. Sobre los 132 meses resultantes (enero 2013 – diciembre 2023) calculamos, para cada celda, la media y la desviación estándar de esos totales y derivamos el coeficiente de variación (CV = σ / μ).

El mapa final resalta los lugares donde la precipitación mensual es más variable: valores altos indican regímenes pluviales muy irregulares, mientras que valores bajos corresponden a climas con lluvias más estables en el tiempo. Al promediar este CV dentro de cada UCS obtendremos una medida de variabilidad climática propia de cada polígono. La relación del CV con la media para cada lugar permite una interpretación directa (p. ej. “para un mes típico de lluvia de 300 mm/mes, un CV de 0,6 significa que la precipitación mensual típica varía un 60 % alrededor de 300 mm/mes, indicando un régimen muy irregular”).

```{r}

# Colección diaria recortada
chirps_daily <- ee$ImageCollection("UCSB-CHG/CHIRPS/DAILY")$
  filterBounds(bbox_ee)$  #descarta las imágenes cuyo footprint no toca tu bbox_ee
  filterDate("2013-01-01", "2023-01-01")

# ── Agregación mensual (mm por mes) ──────────────────────────────────────────
chirps_monthly_ic <- ee$ImageCollection(
  ee$List$sequence(2013, 2023)$map(ee_utils_pyfunc(function(y) {
    ee$List$sequence(1, 12)$map(ee_utils_pyfunc(function(m) {
      start <- ee$Date$fromYMD(y, m, 1)
      end   <- start$advance(1, "month")
      chirps_daily$
        filterDate(start, end)$
        sum()$                         # mm del mes
        clip(bbox_ee)$
        set("system:time_start", start)
    }))
  }))$flatten()
)

# ── (1) CV TEMPORAL POR PÍXEL (mensual) ─────────────────────────────────────
precip_mean_temp <- chirps_monthly_ic$mean()$rename("precip_mean_temp")
precip_sd_temp   <- chirps_monthly_ic$reduce(ee$Reducer$stdDev())$rename("precip_sd_temp")
precip_cv_temp   <- precip_sd_temp$divide(precip_mean_temp)$rename("precip_cv_temp")

# Verificación visual en el visor de Earth Engine
Map$setCenter(lon = -74, lat = 4, zoom = 5)
Map$addLayer(
  precip_cv_temp,
  list(min = 0, max = 1, palette = c("blue","orange","red")),
  "Precip CV temporal (mensual)"
)

```

## 3. Extracción de métricas

Falta texto coherence: La función se encuentra en un script externo.... rgee para la extracción. ...los raster se muestrean a 50m si su resolución es mas fina, lo cual equivale a escala 1:100.000. Si la resolución es mas gruesa, se utiliza la que esté disponible.

```{r exporta_covariables_poligonos}

# Extrae estadísticas (mean / sd) por UCS y las envía a Drive en lotes adaptativos
source(here::here("Scripts", "00_funcion_procesamiento_lotes_imagen.R"), encoding = "UTF-8")

registro_dem <- procesamiento_lotes_imagen(ucs_sf_4326, image = dem_clip, start_idx = 1, max_index = 43384, variable_name = "DEM", scale = 50)

registro_slope <- procesamiento_lotes_imagen(ucs_sf_4326, image = slope_clip, start_idx = 1, max_index = 43384, batch_s = 400, reduce_batch_by = 4, variable_name = "SLOPE", scale = 50)

registro_lst_esp <- procesamiento_lotes_imagen(ucs_sf_4326, image = modis_media_espacial, start_idx = 1, max_index = 43384, batch_s = 300, reduce_batch_by = 3, variable_name = "LST_media_espacial", scale = 500)

registro_lst_temp <- procesamiento_lotes_imagen(ucs_sf_4326, image = modis_temp_cv, start_idx = 1, max_index = 43384, batch_s = 300, reduce_batch_by = 3, variable_name = "LST_cv_temporal", scale = 500)

registro_precip_cv_temporal <- procesamiento_lotes_imagen(ucs_sf_4326, image = precip_cv_temp, start_idx = 1, max_index = nrow(ucs_sf_4326), batch_s = 300, reduce_batch_by = 3, variable_name  = "PRECIP_cv_temporal", scale = 500)

registro_precip_esp <- procesamiento_lotes_imagen(ucs_sf_4326, image = precip_media_espacial, start_idx = 1, max_index = 43384, batch_s = 300,   reduce_batch_by = 3, variable_name  = "PRECIP_media_espacial", scale = 500)


```

**Post procesamiento de .csv**

El código a continuación lee todos los .csv de una propiedad (por ejemplo, "slope"),los combina en un solo data.frame, lo guarda como OUT_slope_combinado.csv (o OUT\_<propiedad>\_combinado.csv según corresponda), y lo sube automáticamente al repositorio del proyecto, usando el paquete googledrive.

```{r reubicar_googledrive}

# Copia local de archivos combinados para reproducibilidad offline
combinar_y_subir_csv <- function(propiedad,
                                 carpeta_drive_id_origen = "17yxwhlpgL4EG8inI5u8Nwi08wOrnhJiM",  # GEE_exports
                                 carpeta_drive_id_destino = "1qJ5S25TZaFWzueNhx1M4Gr3P8JYWKGeU",  # Proyecto
                                 carpeta_temporal = "tmp_csv") {

  # Crea carpeta temporal local si no existe
  if (!dir.exists(carpeta_temporal)) {
    dir.create(carpeta_temporal)
  }

  # Listar archivos en Google Drive (solo .csv con prefijo exacto)
  archivos_drive <- googledrive::drive_ls(
    path = as_id(carpeta_drive_id_origen),
    pattern = glue::glue("^{propiedad}_.*\\.csv$")
  ) |>
    dplyr::filter(stringr::str_ends(name, ".csv"))

  if (nrow(archivos_drive) == 0) {
    stop(glue::glue("No se encontraron archivos CSV para la propiedad '{propiedad}' en GEE_exports."))
  }

  message(glue::glue("📥 Descargando {nrow(archivos_drive)} archivos CSV para '{propiedad}'..."))

  # Descargar archivos al directorio temporal
  purrr::walk2(
    archivos_drive$name,
    archivos_drive$id,
    ~ googledrive::drive_download(
      file = as_id(.y),
      path = file.path(carpeta_temporal, .x),
      overwrite = TRUE
    )
  )

  # Leer y combinar
  archivos_locales <- list.files(path = carpeta_temporal,
                                 pattern = paste0("^", propiedad, "_.*\\.csv$"),
                                 full.names = TRUE)

  combinado <- purrr::map_dfr(archivos_locales, readr::read_csv, show_col_types = FALSE)

  # Escribir archivo combinado
  nombre_salida <- paste0("OUT_", propiedad, "_combinado.csv")
  ruta_salida <- file.path(carpeta_temporal, nombre_salida)
  readr::write_csv(combinado, ruta_salida)

  # Subir a carpeta final de proyecto en Drive
  archivo_subido <- googledrive::drive_upload(
    media = ruta_salida,
    path = as_id(carpeta_drive_id_destino),
    name = nombre_salida,
    overwrite = TRUE
  )

  message(glue::glue("✅ Archivo combinado subido: {archivo_subido$name} (ID: {archivo_subido$id})"))

  # Limpieza automática
  unlink(carpeta_temporal, recursive = TRUE)
  message("🧹 Archivos temporales eliminados.")
}

```

Aplica la función para las covariables. Esto se corre solo una vez, para combinar los csv por lotes.

```{r aplica_funcion_combinacion}

#combinar_y_subir_csv("DEM")
#combinar_y_subir_csv("SLOPE")
#combinar_y_subir_csv("LST_cv_temporal")
#combinar_y_subir_csv("LST_media_espacial") 
#combinar_y_subir_csv("PRECIP_cv_temporal")
#combinar_y_subir_csv("PRECIP_media_espacial") 

```

En este bloque cargamos las tablas .csv exportadas desde Google Earth Engine y las convertimos en objetos sf que conservan la geometría de cada Unidad Cartográfica de Suelo (UCS). Para cada producto (DEM, pendiente, LST, precipitación) se generan de forma sistemática cinco conjuntos de variables:

1.  Media (p. ej. dem_mean).

2.  Coeficiente de variación CV=σ /∣μ∣+ε

Se usa el valor absoluto de la media para que el CV siga midiendo variabilidad aunque existan medias negativas (caso DEM y pendiente) y se añade un pequeño ε=10−6 para evitar divisiones por cero.

3.  CV densificado (CV / Área).

4.  Transformaciones log₁₀ → permiten visualizar colas largas y utilizar escalas continuas.

5.  Estandarizaciones z → útiles en los modelos (centro = 0, varianza = 1).

Excepto DEM y pendiente (que pueden tener medias ≤ 0), los demás promedios son positivos; por tanto, no requieren el ajuste ∣μ∣

```{r carga_covariables}

# ─────────────────────────────────────────────────────────────────────────────
# 0 · Ajuste de precisión para divisiones seguras
# ─────────────────────────────────────────────────────────────────────────────
eps <- 1e-6                         # ε evita CV = σ/0
safe_log10 <- function(x) log10(pmax(x, eps))

# ─────────────────────────────────────────────────────────────────────────────
# 1 · DEM (media & CV espacial)
# ─────────────────────────────────────────────────────────────────────────────
dem_cv <- readr::read_csv(
  here::here("Data/OUT_covars_csv/OUT_DEM_combinado.csv"),
  show_col_types = FALSE
)

covars_dem <- st_as_sf(
  data.frame(dem_cv, geometry = geojson_sf(dem_cv$.geo)), crs = 4326
) |>
  dplyr::rename(dem_mean = mean) |>
  dplyr::mutate(
    dem_cv          = stdDev / pmax(abs(dem_mean), eps),
    log_dem_cv      = safe_log10(dem_cv),
    dem_cv_dens     = dem_cv / AREA_HA,
    log_dem_cv_dens = safe_log10(dem_cv_dens),
    across(c(dem_cv, log_dem_cv, dem_cv_dens, log_dem_cv_dens, dem_mean),
           ~ scale(.x)[, 1], .names = "{.col}_z")
  ) |>
  dplyr::select(-.geo, -stdDev, -system.index)   

# ─────────────────────────────────────────────────────────────────────────────
# 2 · SLOPE (media & CV espacial)
# ─────────────────────────────────────────────────────────────────────────────
slope_cv <- readr::read_csv(
  here::here("Data/OUT_covars_csv/OUT_SLOPE_combinado.csv"),
  show_col_types = FALSE
)

covars_slope <- st_as_sf(
  data.frame(slope_cv, geometry = geojson_sf(slope_cv$.geo)), crs = 4326
) |>
  dplyr::rename(slope_mean = mean) |>
  dplyr::mutate(
    slope_cv          = stdDev / pmax(abs(slope_mean), eps),
    log_slope_cv      = safe_log10(slope_cv),
    slope_cv_dens     = slope_cv / AREA_HA,
    log_slope_cv_dens = safe_log10(slope_cv_dens),
    across(c(slope_cv, log_slope_cv, slope_cv_dens, log_slope_cv_dens, slope_mean),
           ~ scale(.x)[, 1], .names = "{.col}_z")
  ) |>
  dplyr::select(-.geo, -stdDev, -system.index)   

# ─────────────────────────────────────────────────────────────────────────────
# 3 · LST media espacial (2013-2023)
# ─────────────────────────────────────────────────────────────────────────────
lst_media_esp <- readr::read_csv(
  here::here("Data/OUT_covars_csv/OUT_LST_media_espacial_combinado.csv"),
  show_col_types = FALSE
)

covars_lst_media <- st_as_sf(
  data.frame(lst_media_esp, geometry = geojson_sf(lst_media_esp$.geo)), crs = 4326
) |>
  dplyr::rename(lst_mean = mean) |>
  dplyr::mutate(
    log_lst_mean        = safe_log10(lst_mean),
    lst_mean_dens       = lst_mean / AREA_HA,
    log_lst_mean_dens   = safe_log10(lst_mean_dens),
    across(c(lst_mean, log_lst_mean, lst_mean_dens, log_lst_mean_dens),
           ~ scale(.x)[, 1], .names = "{.col}_z")
  ) |>
  dplyr::select(-.geo, -stdDev, -system.index)   

# ─────────────────────────────────────────────────────────────────────────────
# 4 · LST CV temporal (2013-2023)
# ─────────────────────────────────────────────────────────────────────────────
lst_cv_temp <- readr::read_csv(
  here::here("Data/OUT_covars_csv/OUT_LST_cv_temporal_combinado.csv"),
  show_col_types = FALSE
)

covars_lst_cv_temp <- st_as_sf(
  data.frame(lst_cv_temp, geometry = geojson_sf(lst_cv_temp$.geo)), crs = 4326
) |>
  dplyr::rename(lst_cv_temp = mean) |>
  dplyr::mutate(
    log_lst_cv_temp        = safe_log10(lst_cv_temp),
    lst_cv_temp_dens       = lst_cv_temp / AREA_HA,
    log_lst_cv_temp_dens   = safe_log10(lst_cv_temp_dens),
    across(c(lst_cv_temp, log_lst_cv_temp, lst_cv_temp_dens, log_lst_cv_temp_dens),
           ~ scale(.x)[, 1], .names = "{.col}_z")
  ) |>
  dplyr::select(-.geo, -stdDev, -system.index)   

# ─────────────────────────────────────────────────────────────────────────────
# 5 · PRECIP CV temporal  &  6 · PRECIP media espacial (idéntica lógica)
# ─────────────────────────────────────────────────────────────────────────────

# Precip cv temporal
precip_cv_temp <- readr::read_csv(
  here::here("Data/OUT_covars_csv/OUT_PRECIP_cv_temporal_combinado.csv"),
  show_col_types = FALSE
)

covars_precip_cv_temp <- st_as_sf(
  data.frame(precip_cv_temp, geometry = geojson_sf(precip_cv_temp$.geo)), crs = 4326
) |>
  dplyr::rename(precip_cv_temp = mean) |>
  dplyr::mutate(
    log_precip_cv_temp        = safe_log10(precip_cv_temp),
    precip_cv_temp_dens       = precip_cv_temp / AREA_HA,
    log_precip_cv_temp_dens   = safe_log10(precip_cv_temp_dens),
    across(c(precip_cv_temp, log_precip_cv_temp, precip_cv_temp_dens, log_precip_cv_temp_dens),
           ~ scale(.x)[, 1], .names = "{.col}_z")
  ) |>
  dplyr::select(-.geo, -stdDev, -system.index)   


# Precip media espacial
precip_media_esp <- readr::read_csv(
  here::here("Data/OUT_covars_csv/OUT_PRECIP_media_espacial_combinado.csv"),
  show_col_types = FALSE
)

covars_precip_media <- st_as_sf(
  data.frame(precip_media_esp, geometry = geojson_sf(precip_media_esp$.geo)), crs = 4326
) |>
  dplyr::rename(precip_mean = mean) |>
  dplyr::mutate(
    log_precip_mean        = safe_log10(precip_mean),
    precip_mean_dens       = precip_mean / AREA_HA,
    log_precip_mean_dens   = safe_log10(precip_mean_dens),
    across(c(precip_mean, log_precip_mean, precip_mean_dens, log_precip_mean_dens),
           ~ scale(.x)[, 1], .names = "{.col}_z")
  ) |>
  dplyr::select(-.geo, -stdDev, -system.index)   


```

## 4. EDA covariables

Ya que `dem_cv_sf`, `slope_cv_sf` y `ucs_rao_sf` comparten `id_creado` como identificador único, se hace un `left_join` sucesivo para combinar sus métricas

```{r}

# Unir a la tabla base
modelo_df <- ucs_rao_sf |>
  left_join(covars_dem |> st_drop_geometry(),        by = c("id_creado", "AREA_HA", "UCSuelo")) |>
  left_join(covars_slope |> st_drop_geometry(),      by = c("id_creado", "AREA_HA", "UCSuelo")) |>
  left_join(covars_lst_cv_temp  |> st_drop_geometry(),    by = c("id_creado", "AREA_HA", "UCSuelo")) |>
  left_join(covars_lst_media |> st_drop_geometry(),    by = c("id_creado", "AREA_HA", "UCSuelo")) |>
  left_join(covars_precip_cv_temp |> st_drop_geometry(),  by = c("id_creado", "AREA_HA", "UCSuelo")) |>
  left_join(covars_precip_media |> st_drop_geometry(), by = c("id_creado", "AREA_HA", "UCSuelo"))

```

### 4.1 Distribuciones

Se verifican visualmente las distribuciones de la magnitud y coeficiente de variación de las covariables. Debido a que el coeficiente de variación

```{r}

# Función general para histogramas
common_hist <- function(data, var, title, xlab){
  ggplot(dplyr::filter(data, is.finite({{ var }})), aes({{ var }})) +
    ggdist::stat_histinterval(fill = "#56B4E9", colour = "black") +  # sin “bins”
    geom_density(aes(y = after_stat(scaled)), colour = "#FFD700",
                 linewidth = 0.8) +
    labs(title = title, x = xlab, y = "Frecuencia") +
    theme_minimal(base_size = 12)
}

# Magnitudes ---------------------------------------------------------------
p_dem_mean   <- common_hist(modelo_df, dem_mean,   "Elevación media",           "m")
p_slope_mean <- common_hist(modelo_df, slope_mean, "Pendiente media",           "°")
p_lst_mean   <- common_hist(modelo_df, lst_mean,   "LST media",                "°C")
p_prec_mean  <- common_hist(modelo_df, precip_mean,"Precip. media mensual","mm·mes⁻¹")

# log(CV) ------------------------------------------------------------------
p_dem_log_cv   <- common_hist(modelo_df, log_dem_cv,
                              expression(log[10]*"CV DEM"),          expression(log[10]*"CV"))
p_slope_log_cv <- common_hist(modelo_df, log_slope_cv,
                              expression(log[10]*"CV pendiente"),    expression(log[10]*"CV"))
p_lst_log_cv   <- common_hist(modelo_df, log_lst_cv_temp,
                              expression(log[10]*"CV LST"),          expression(log[10]*"CV"))
p_prec_log_cv  <- common_hist(modelo_df, log_precip_cv_temp,
                              expression(log[10]*"CV precipitación"),expression(log[10]*"CV"))

# log(CV dens) -------------------------------------------------------------
p_dem_log_cvd   <- common_hist(modelo_df, log_dem_cv_dens,
                               expression(log[10]*"CVdens DEM"),          expression(log[10]*"CVdens"))
p_slope_log_cvd <- common_hist(modelo_df, log_slope_cv_dens,
                               expression(log[10]*"CVdens pendiente"),    expression(log[10]*"CVdens"))
p_lst_log_cvd   <- common_hist(modelo_df, log_lst_cv_temp_dens,
                               expression(log[10]*"CVdens LST"),          expression(log[10]*"CVdens"))
p_prec_log_cvd  <- common_hist(modelo_df, log_precip_cv_temp_dens,
                               expression(log[10]*"CVdens precipitación"),expression(log[10]*"CVdens"))

# Mosaico 4×3 --------------------------------------------------------------

p_mosaico_hist <- (
  p_dem_mean  | p_slope_mean  | p_lst_mean  | p_prec_mean) /
  (p_dem_log_cv | p_slope_log_cv | p_lst_log_cv | p_prec_log_cv) /
  (p_dem_log_cvd| p_slope_log_cvd| p_lst_log_cvd| p_prec_log_cvd)

# Muestra en visor
p_mosaico_hist

# Guardar si se desea
ggsave(
  here::here("Figures", "mosaico_hist_covariables.png"),
  plot   = p_mosaico_hist,
  width  = 12, height = 9, dpi = 350
)

```

### 4.2 Visualización espacial de las covariables

Se visualizan las covariables rasterizadas. Las escalas de colores se reflejan asociaciones simbólicas con los procesos físicos que representan (e.g. rojo, mayor temperatura, azul, mayor precipitación). La escala de mapas de coeficientes de varaición representa n

```{r}

# Definición de colores --------------------------------------------------------

# Paletas de magnitud  (10 pasos → se interpolan en la escala) 

pal_dem   <- paletteer::paletteer_c("grDevices::terrain.colors", n = 10)
pal_slope <- paletteer::paletteer_c("grDevices::Temps",          n = 10)
pal_lst   <- paletteer::paletteer_c("ggthemes::Red-Gold",        n = 10)
pal_prec  <- paletteer::paletteer_c("grDevices::Earth",          n = 10) # "grDevices::Roma"


# Gradientes monocromáticos  blanco → color_extremo  (para los CV PUROS)

mono_pal <- function(col_hex, n = 100) colorRampPalette(c("#ffffff", col_hex))(n)

pal_dem_cv   <- mono_pal(head(pal_dem, 1))   # ← ahora usa el 1er color
pal_slope_cv <- mono_pal(tail(pal_slope, 1))
pal_lst_cv   <- mono_pal(tail(pal_lst,   1))
pal_prec_cv  <- mono_pal(tail(pal_prec,  1))


# Función genérica para mapas --------------------------------------------------

# ARGUMENTOS
#   data   : data.frame / tibble con geometría sf.
#   var    : nombre de la columna a mapear (tidy-eval, sin comillas).
#   pal    : vector de colores hex (paleta continua ya generada).
#   titulo : texto para el título del mapa.

map_mag <- function(data, var, pal, titulo, leyenda){
  ggplot(data) +
    geom_sf(aes(fill = {{ var }}), colour = NA) +
    scale_fill_gradientn(
      colours = pal, 
      na.value = "white",
      guide   = guide_colourbar(
        direction      = "vertical",
        barwidth       = unit(0.25, "cm"),
        barheight      = unit(2.5,  "cm"),
        title.position = "top"
        ),
      name = leyenda
      ) +
    labs(title = titulo) +
    theme_minimal() + 
    theme(legend.justification = c("right", "top"))
}

map_cv <- function(data, var, pal, titulo){
  ggplot(data |> dplyr::filter({{ var }} > 0)) + #Descarta valores cero o negativos antes de transformar
    geom_sf(aes(fill = {{ var }}), colour = NA) +
    scale_fill_gradientn(
      colours = pal,
      trans   = "log10", # usa escala log-10 para contrastar valores bajos y altos de CV
      breaks  = scales::trans_breaks("log10", function(x) 10^x),
      labels  = scales::label_number(accuracy = .001),
      na.value = "white",
      guide   = guide_colourbar(
        direction      = "vertical",
        barwidth       = unit(0.25, "cm"),
        barheight      = unit(2.5,  "cm"),
        title.position = "top"
        ),
      name    = "CV"
    ) +
    labs(title = titulo) +
    theme_minimal() + 
    theme(legend.justification = c("right", "top"))
}

##############################################################################

# Generación de mapas ----------------------------------------------------------

# Mapas de magnitud

p_dem_mean   <- map_mag(modelo_df, dem_mean,   pal_dem,   "Media de DEM (m)",               "m")
p_slope_mean <- map_mag(modelo_df, slope_mean, pal_slope, "Media de pendiente (°)",         "°")
p_lst_mean   <- map_mag(modelo_df, lst_mean,  pal_lst,   "Media de LST (°C)",              "°C")
p_prec_mean  <- map_mag(modelo_df, precip_mean,pal_prec, "Media de precipitación (mm·mes⁻¹)","mm")


# Mapas de variabilidad  (CV, NO densificado)

p_dem_cv   <- map_cv(modelo_df, dem_cv,        pal_dem_cv,   "CV de DEM")
p_slope_cv <- map_cv(modelo_df, slope_cv,      pal_slope_cv, "CV de pendiente")
p_lst_cv   <- map_cv(modelo_df, lst_cv_temp,   pal_lst_cv,   "CV de LST")
p_prec_cv  <- map_cv(modelo_df, precip_cv_temp,pal_prec_cv,  "CV de precipitación")


# Composición de figura -----------------------------------------------------------

# Mosaico 4 × 2   (fila superior = magnitud, inferior = CV)

p_mosaico <- (p_dem_mean | p_slope_mean | p_lst_mean | p_prec_mean) /
             (p_dem_cv   | p_slope_cv   | p_lst_cv   | p_prec_cv  )

ggsave(
  here::here("Figures", "mosaico_mapa_covariables.png"),
  plot   = p_mosaico,
  width  = 12, height = 6, dpi = 350
)

```
