---
title: "Modelos para dependencia y heterogeneidad espacial"
author: "Carlos M. GuÃ­o Blanco"
format: html
editor: visual
---

Este cuaderno documenta el paso desde el anÃ¡lisis exploratorio hacia el **modelado continuo y espacialmente explÃ­cito** de la pedodiversidad (respuesta: `log_Qdens`, es decir, logâ‚â‚€ (Q / Ãrea)).\

Partiremos de los polÃ­gonos UCS con todas las covariables climÃ¡ticas-topogrÃ¡ficas ya integradas, generaremos la matriz de pesos por **contigÃ¼idad queen row-standardized**, y compararemos distintos modelos espacialesâ€”SAR error/lag, variantes Durbin, SEMâ€”hasta llegar a un **modelo CAR bayesiano con INLA** y a un **modelo jerÃ¡rquico con efectos aleatorios por era geolÃ³gica**.\

Cada secciÃ³n estÃ¡ â€œcacheadaâ€ para permitir ejecuciÃ³n modular y reproducible.

```{r configuracion}

#Para exportar como .R plano
# knitr::purl('06_analisis_SAR_CAR__jerarquicos.qmd')

if (!"pacman" %in% rownames(installed.packages())) install.packages("pacman")
pacman::p_load(
  here,         # manejo de rutas relativas al proyecto
  remotes,      # instalar paquetes desde GitHub (si llegamos a necesitarlos)
  sf,           # lectura y manipulaciÃ³n de objetos espaciales vectoriales
  dplyr,        # verbos de manipulaciÃ³n de data frames (filter, mutate, joins)
  tidyr,        # pivoteo y desanidado de datos (pivot_longer, unnest, etc.)
  readr,        # lectura/escritura rÃ¡pida de archivos CSV
  geojsonsf,    # GeoJSON â†” sf rÃ¡pido (geojson_sf)
  rmapshaper,   # SimplificaciÃ³n de geometrÃ­as
  stringr,      # ManipulaciÃ³n d textos
  ggplot2,      # sistema de grÃ¡ficos
  ggdist,       # distribuciones y visuales tipo half-eye / histinterval
  patchwork,    # combinaciÃ³n de grÃ¡ficos ggplot (p1 + p2)
  paletteer,    # acceso a mÃºltiples paletas (viridis, wesanderson, etc.)
  scales,       # helpers de ejes y transformaciones (log10, percentiles)
  grid,         # utilidades de bajo nivel para grÃ¡ficos (layouts, grobs)
  GGally,       # correlogramas y extensiones ggplot
  sjPlot,       # visualizaciÃ³n de modelos (coeficientes, efectos marginales)
  spdep,        # estructuras de vecinos y pruebas de autocorrelaciÃ³n
  spatialreg,   # modelos SAR / SEM / SDM / SDEM / SARAR
  spaMM,        # Modelos mixtos
  performance,  # mÃ©tricas de ajuste (pseudo-RÂ², VIF, etc.)
  classInt,     # cortes de intervalos (quantile, jenks, etc.)
  INLA,         # modelos Bayesianos rÃ¡pidos (CAR/BYM/Leroux)
  lme4,         # modelos mixtos jerÃ¡rquicos (GLMM)
  MuMIn,        # RÂ² marginal/condicional para modelos mixtos
  googledrive   # autenticaciÃ³n y manejo de archivos en Google Drive
)

theme_set(theme_minimal(base_size = 13))

# Para instalar INLA:
# https://www.r-inla.org/download-install

```

## 1. Carga de datos

Importamos la capa de Unidades CartogrÃ¡ficas de Suelo (UCS) previamente armonizada. Al validar geometrÃ­as y quedarnos con los campos clave (`id_creado`, `UCSuelo`, `AREA_HA`, `Q`) dejamos una versiÃ³n ligera pero completa que servirÃ¡ de eje para unir, mÃ¡s adelante, las covariables ambientales y la geologÃ­a.

```{r carga_ucs}

# Capa cruda tal como sale de la funciÃ³n externa ---------------
source(here::here("Scripts", "00_funcion_carga_ucs_procesadas_qs.R"),
       encoding = "UTF-8")


# VersiÃ³n â€œlimpiaâ€ en WGS-84 ------------------------------------------------
ucs_sf_4326 <- ucs_rao_sf |>
  sf::st_make_valid() |>
  sf::st_transform(4326) |>
  dplyr::select(id_creado, UCSuelo, AREA_HA, Q)


```

Definimos aquÃ­ constantes y funciones auxiliares de uso recurrente. El pequeÃ±o Îµ protege divisiÃ³n o logaritmos frente a ceros, mientras que las paletas garantizan una estÃ©tica uniforme en todas las figuras del cuaderno. Al declararlas una sola vez evitamos redefiniciones y mantenemos la coherencia visual.

```{r utilidades}

# Ajuste de precisiÃ³n para divisiones seguras
eps        <- 1e-6                                # Îµ evita CV = Ïƒ/0
safe_log10 <- function(x) log10(pmax(x, eps))     # log10 con piso

# Paletas continuas y discretas
pal_continuo <- paletteer::paletteer_c("grDevices::Zissou 1", 100)
pal_qualitat <- paletteer::paletteer_d("wesanderson::Zissou1", 5)
```

En los siguientes sub-bloques leemos los CSV de covariables exportados desde GEE y calculamos mÃ©tricas derivadas (coeficiente de variaciÃ³n, densidades, transformaciones log y estandarizaciones z). Al final de la secciÃ³n cada conjunto (`covars_*`) queda listo para unirse a la tabla base de UCS, proporcionando la dimensiÃ³n ambiental necesaria para los modelos espaciales.

```{r carga_covariables}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 1 Â· DEM  Â· media, CV y derivados (todas las variables en espaÃ±ol)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
dem_csv <- readr::read_csv(           # <- nombre lÃ³gico del objeto CSV
  here::here("Data/OUT_covars_csv/OUT_DEM_combinado.csv"),
  show_col_types = FALSE
)

covars_dem <- st_as_sf(
  data.frame(dem_csv, geometry = geojson_sf(dem_csv$.geo)), crs = 4326
) |>
  # Â«mediaÂ» en lugar de Â«meanÂ»
  dplyr::rename(dem_media = mean) |>
  dplyr::mutate(
    # Coef. de variaciÃ³n espacial de la elevaciÃ³n
    dem_cv              = stdDev / pmax(abs(dem_media), eps),
    log_dem_cv          = safe_log10(dem_cv),

    # Densidad de CV por unidad de superficie
    dem_cv_densidad     = dem_cv / AREA_HA,
    log_dem_cv_densidad = safe_log10(dem_cv_densidad),

    # VersiÃ³n estandarizada (Z-score) de cada mÃ©trica
    across(c(dem_media, dem_cv, log_dem_cv,
             dem_cv_densidad, log_dem_cv_densidad),
           ~ scale(.x)[,1], .names = "{.col}_z")
  ) |>
  dplyr::select(-.geo, -stdDev, -system.index)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 2 Â· SLOPE (media & CV espacial)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
slope_cv <- readr::read_csv(
  here::here("Data/OUT_covars_csv/OUT_SLOPE_combinado.csv"),
  show_col_types = FALSE
)

covars_pendiente <- st_as_sf(
  data.frame(slope_cv, geometry = geojson_sf(slope_cv$.geo)), crs = 4326
) |>
  dplyr::rename(pendiente_media = mean) |>
  dplyr::mutate(
    pendiente_cv          = stdDev / pmax(abs(pendiente_media), eps),
    log_pendiente_cv      = safe_log10(pendiente_cv),
    pendiente_cv_densidad = pendiente_cv / AREA_HA,
    log_pendiente_cv_densidad = safe_log10(pendiente_cv_densidad),
    across(c(pendiente_cv, log_pendiente_cv,
             pendiente_cv_densidad, log_pendiente_cv_densidad,
             pendiente_media),
           ~ scale(.x)[,1], .names = "{.col}_z")
  ) |>
  dplyr::select(-.geo, -stdDev, -system.index)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 3 Â· LST media espacial (2013-2023)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
lst_media_esp <- readr::read_csv(
  here::here("Data/OUT_covars_csv/OUT_LST_media_espacial_combinado.csv"),
  show_col_types = FALSE
)

covars_lst_media <- st_as_sf(
  data.frame(lst_media_esp, geometry = geojson_sf(lst_media_esp$.geo)), crs = 4326
) |>
  dplyr::rename(lst_media = mean) |>
  dplyr::mutate(
    log_lst_media          = safe_log10(lst_media),
    lst_media_densidad     = lst_media / AREA_HA,
    log_lst_media_densidad = safe_log10(lst_media_densidad),
    across(c(lst_media, log_lst_media,
             lst_media_densidad, log_lst_media_densidad),
           ~ scale(.x)[,1], .names = "{.col}_z")
  ) |>
  dplyr::select(-.geo, -stdDev, -system.index)  

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 4 Â· LST CV temporal (2013-2023)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

lst_cv_temp <- readr::read_csv(
  here::here("Data/OUT_covars_csv/OUT_LST_cv_temporal_combinado.csv"),
  show_col_types = FALSE
)

covars_lst_cv_temp <- st_as_sf(
  data.frame(lst_cv_temp, geometry = geojson_sf(lst_cv_temp$.geo)), crs = 4326
) |>
  dplyr::rename(lst_cv_temporal = mean) |>
  dplyr::mutate(
    log_lst_cv_temporal          = safe_log10(lst_cv_temporal),
    lst_cv_temporal_densidad     = lst_cv_temporal / AREA_HA,
    log_lst_cv_temporal_densidad = safe_log10(lst_cv_temporal_densidad),
    across(c(lst_cv_temporal, log_lst_cv_temporal,
             lst_cv_temporal_densidad, log_lst_cv_temporal_densidad),
           ~ scale(.x)[,1], .names = "{.col}_z")
  ) |>
  dplyr::select(-.geo, -stdDev, -system.index)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 5 Â· PRECIP CV temporal  &  6 Â· PRECIP media espacial (idÃ©ntica lÃ³gica)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Precip cv temporal
precip_cv_temp <- readr::read_csv(
  here::here("Data/OUT_covars_csv/OUT_PRECIP_cv_temporal_combinado.csv"),
  show_col_types = FALSE
)

covars_precip_cv_temp <- st_as_sf(
  data.frame(precip_cv_temp, geometry = geojson_sf(precip_cv_temp$.geo)), crs = 4326
) |>
  dplyr::rename(precip_cv_temporal = mean) |>
  dplyr::mutate(
    log_precip_cv_temporal          = safe_log10(precip_cv_temporal),
    precip_cv_temporal_densidad     = precip_cv_temporal / AREA_HA,
    log_precip_cv_temporal_densidad = safe_log10(precip_cv_temporal_densidad),
    across(c(precip_cv_temporal, log_precip_cv_temporal,
             precip_cv_temporal_densidad, log_precip_cv_temporal_densidad),
           ~ scale(.x)[,1], .names = "{.col}_z")
  ) |>
  dplyr::select(-.geo, -stdDev, -system.index)   


# Precip media espacial
precip_media_esp <- readr::read_csv(
  here::here("Data/OUT_covars_csv/OUT_PRECIP_media_espacial_combinado.csv"),
  show_col_types = FALSE
)

covars_precip_media <- st_as_sf(
  data.frame(precip_media_esp, geometry = geojson_sf(precip_media_esp$.geo)), crs = 4326
) |>
  dplyr::rename(precip_media = mean) |>
  dplyr::mutate(
    log_precip_media          = safe_log10(precip_media),
    precip_media_densidad     = precip_media / AREA_HA,
    log_precip_media_densidad = safe_log10(precip_media_densidad),
    across(c(precip_media, log_precip_media,
             precip_media_densidad, log_precip_media_densidad),
           ~ scale(.x)[,1], .names = "{.col}_z")
  ) |>
  dplyr::select(-.geo, -stdDev, -system.index)


```

Descargamos el mapa geolÃ³gico 1 : 500 000 del SGC vÃ­a servicio REST y lo reclasificamos en eras (Cz, Mz, Pz, Ptz). Esa simplificaciÃ³n facilita interpretar la historia geolÃ³gica dominante de cada UCS y nos servirÃ¡ mÃ¡s adelante como posible factor jerÃ¡rquico o como covariable categÃ³rica en modelos mixtos.

```{r carga_geologico}

url_base   <- "https://srvags.sgc.gov.co/arcgis/rest/services/Mapa_Geologico_Colombia/Mapa_Geologico_Colombia_V2023/MapServer/733/query"
url_geo    <- httr::modify_url(
  url_base,
  query = list(where = "1=1", outFields = "*",
               returnGeometry = "true", f = "geojson")
)

geo_sf_wgs84 <- sf::st_read(url_geo, quiet = TRUE) |>
  sf::st_make_valid() |>
  mutate(
    # LIMPIEZA -----------------------------------------------------------------
    edad_limpia = Edad |>
      str_replace_all("\\?", "") |>
      str_trim() |>
      str_to_lower() |>
      stringi::stri_trans_general("Latin-ASCII") |>
      str_replace_all("-", " ") |>
      str_squish(),
    
    # RECLASIFICACIÃ“N POR ERA --------------------------------------------------
    era_geo = case_when(
      # 1) CENOZOICO -----------------------------------------------------------
      str_detect(edad_limpia, regex(
        "paleoceno|eoceno|oligoceno|mioceno|plioceno|pleistoceno|holoceno|
         aquitaniano|burdigaliano|langhiano|serravaliano|tortoniano|messiniano|
         zancliano|rupeliano|thanetiano|lutetiano|bartoniano|priaboniano|
         selandiano|daniense|chattiano|cuaternario|mesiniano",
        ignore_case = TRUE)) ~ "Cz",
      
      # 2) MESOZOICO -----------------------------------------------------------
      str_detect(edad_limpia, regex(
        "triasico|jurasico|cretacico|berriasiano|valanginiano|barremiano|
         aptiano|albiano|cenomaniano|turoniano|coniaciano|santoniano|
         campaniano|maastrichtiano",
        ignore_case = TRUE)) ~ "Mz",
      
      # 3) PALEOZOICO ----------------------------------------------------------
      str_detect(edad_limpia, regex(
        "\\bcambrico\\b|\\bordovicico\\b|\\bsilurico\\b|\\bdevonico\\b|
         \\bmississipiano\\b|\\bpridoliano\\b|\\bcarbonifero\\b|
         \\bpennsylvaniano\\b|\\bpermico\\b|\\bpaleozoico\\b",
        ignore_case = TRUE)) ~ "Pz",
      
      # 4) PROTEROZOICO --------------------------------------------------------
      str_detect(edad_limpia, regex(
        "sideriano|rhyaciano|orosiriano|statheriano|calymmiano|ectasiano|
         steniano|toniano|criogenico|ediacariano|mesoproterozoico|
         neoproterozoico|proterozoico",
        ignore_case = TRUE)) ~ "Ptz",
      
      # 5) SIN DATO ------------------------------------------------------------
      TRUE ~ "NA"
    )
  ) |>
  st_transform(4326) |>
  select(descripcion_geo = Descripcion, era_geo, edad_limpia)
```

## 2. Procesamiento

AquÃ­ ensamblamos la tabla maestra del estudio: partimos de las UCS, aÃ±adimos la variable respuesta (log_Qdens), cruzamos con la era geolÃ³gica y, por Ãºltimo, unimos todas las covariables ambientales. El objeto resultante (modelo_sf) concentra en un Ãºnico data-frame espacial toda la informaciÃ³n necesaria para explorar autocorrelaciÃ³n y ajustar los modelos SAR/CAR.

```{r procesamiento_datos}

## Era geolÃ³gica dominante por intersecciÃ³n ---------------------------
ucs_geo_df <- sf::st_join(
  ucs_sf_4326 |> dplyr::select(id_creado),     
  geo_sf_wgs84,
  join = sf::st_intersects,
  left = TRUE
) |>
  sf::st_drop_geometry() |>
  dplyr::distinct(id_creado, .keep_all = TRUE)

## Ensamblar modelo_sf (respuesta + covariables + geologÃ­a) -----------------
modelo_sf <- ucs_sf_4326 |>
  # respuesta
  dplyr::mutate(
    Q      = dplyr::if_else(Q == 0, 1e-3, Q),   # evita log(0)
    Qdens  = Q / AREA_HA,
    log_Qdens = log10(Qdens)
  ) |>
  # geologÃ­a
  dplyr::left_join(ucs_geo_df, by = "id_creado") |>
  # covariables
  left_join(covars_dem            |> sf::st_drop_geometry(),
            by = c("id_creado","AREA_HA","UCSuelo")) |>
  left_join(covars_pendiente      |> sf::st_drop_geometry(),
            by = c("id_creado","AREA_HA","UCSuelo")) |>
  left_join(covars_lst_cv_temp    |> sf::st_drop_geometry(),
            by = c("id_creado","AREA_HA","UCSuelo")) |>
  left_join(covars_lst_media      |> sf::st_drop_geometry(),
            by = c("id_creado","AREA_HA","UCSuelo")) |>
  left_join(covars_precip_cv_temp |> sf::st_drop_geometry(),
            by = c("id_creado","AREA_HA","UCSuelo")) |>
  left_join(covars_precip_media   |> sf::st_drop_geometry(),
            by = c("id_creado","AREA_HA","UCSuelo"))

## Vista rÃ¡pida -----------------------------------------------------------
glimpse(modelo_sf, width = 80)
modelo_df <- sf::st_drop_geometry(modelo_sf)


```

## 3. DiagnÃ³stico de autocorrelaciÃ³n espacial (Moran I y LISA)

En esta secciÃ³n construiremos la malla de vecinos Queen, obtendremos la matriz de
pesos W, calcularemos la autocorrelaciÃ³n **global** (Moran I) y la
autocorrelaciÃ³n **local** (LISA).  El objetivo es confirmar la presencia de
dependencia espacial y localizar *hot-spots* y *cold-spots* de pedodiversidad
antes de pasar a los modelos SAR / CAR.
  etc.

### 3.1 ConstrucciÃ³n de la red Queen y de la matriz W

El siguiente bloque:

1. prepara un `sf` liviano que conserva solo `id_creado`, `log_Qdens`
y la geometrÃ­a;  
2. simplifica los vÃ©rtices para acelerar la vecindad;  
3. desactiva la geometrÃ­a esfÃ©rica (`sf_use_s2(FALSE)`) para que
`poly2nb()` trabaje en 2-D;  
4. crea la lista de vecinos Queen y la convierte en matriz de pesos
fila-estandarizada.


```{r matriz_vecindad}

## 0 Â· Preparamos un objeto liviano con respuesta + geometrÃ­a --------------
modelo_sf_s <- modelo_sf |>
  dplyr::select(id_creado, log_Qdens, geometry) |>
  sf::st_simplify(dTolerance = 0.0005, preserveTopology = TRUE) |>
  sf::st_make_valid()

## 1 Â· Forzamos geometrÃ­a plana en {spdep} ----------------------------------
sf::sf_use_s2(FALSE)   # debe ejecutarse antes de poly2nb()

## 2 Â· Lista de vecinos Queen (snap evita â€œgrietasâ€ numÃ©ricas) --------------
nb_queen <- spdep::poly2nb(
  modelo_sf_s,
  queen = TRUE,
  snap  = 1e-06,   # â‰ˆ 0.11 m
  useC  = TRUE
)

## 3 Â· Matriz de pesos W (fila-estandarizada) -------------------------------
lw_queen <- spdep::nb2listw(
  nb_queen,
  style       = "W",
  zero.policy = TRUE
)

## 4 Â· Guardamos los polÃ­gonos sin vecinos por si se quieren revisar mÃ¡s tarde
sin_vecinos <- which(spdep::card(nb_queen) == 0)
length(sin_vecinos)        # â‰ˆ 0 si todo va bien


```

Con un grÃ¡fico rÃ¡pido inspeccionamos la malla de vecinos resultante. Ver las aristas superpuestas a los polÃ­gonos nos da confianza en que la topologÃ­a estÃ¡ bien capturada antes de pasar a las pruebas formales de autocorrelaciÃ³n.

```{r visualizacion_pesos}

# matriz de coordenadas de centroides para nb2lines()
coords <- sf::st_coordinates(sf::st_centroid(modelo_sf_s))

ggplot() +
  geom_sf(data = modelo_sf_s, colour = "grey80", fill = NA, linewidth = .1) +
  geom_segment(
    data = spdep::nb2lines(nb_queen, coords = coords),
    aes(x = x1, y = y1, xend = x2, yend = y2),
    colour = "#56B4E9", linewidth = .2, alpha = .4
  ) +
  labs(title = "Malla de vecinos (contigÃ¼idad Queen)") +
  theme_void()


```

### 3.2 Analisis de autocorrelaciÃ³n Moran I y LISA

En los siguientes chunks se calcula (i) el Moran I global de log_Qdens bajo aleatorizaciÃ³n y (ii) los indicadores locales (LISA). Solo se incluyen las UCS que poseen un valor distinto de NA y cumplen uno de estos criterios de vecindad:

OpciÃ³n A â€“ recomendada (activada por defecto)
Al menos un vecino tiene log_Qdens â‰  NA.
Esto evita que el lag se rellene con 0 cuando todos los vecinos carecen de dato, y elimina la franja horizontal artificial del diagrama de dispersiÃ³n.

OpciÃ³n B â€“ legacy
Basta con que el polÃ­gono tenga â‰¥ 1 vecino, sin verificar si esos vecinos presentan datos.
Ãšsala solo si necesitas reproducir resultados antiguos; reintroduce la franja horizontal.

Para cambiar de una opciÃ³n a la otra basta con comentar / des-comentar la lÃ­nea indicada.
subset.listw() requiere un vector lÃ³gico (TRUE / FALSE), de ahÃ­ la conversiÃ³n de Ã­ndices a keep_log.

Al activar la opciÃ³n A se descartan aquellos polÃ­gonos cuyos vecinos no tienen dato vÃ¡lido en log_Qdens. En la definiciÃ³n clÃ¡sica de Moran I, el tÃ©rmino 
ğ‘Š
ğ‘¦
Wy (lag espacial) es el promedio ponderado de los valores de los vecinos; si todos esos vecinos son NA, la funciÃ³n de spdepâ€”al operar con zero.policy = TRUEâ€”reemplaza el lag por 0.
Esos ceros artificiales inflan la semejanza entre la UCS y su vecindario (porque comparan un dato real con 0, valor que suele quedar lejos de la media global), de modo que:

Con la opciÃ³n B esos polÃ­gonos se mantienen, su lag â€œ0â€ introduce correlaciones espurias y el Moran I global se sobre-estima.

Con la opciÃ³n A se eliminan de la prueba (no cumplen al menos un vecino con dato), de forma que el estadÃ­stico se calcula sÃ³lo con vecindarios reales. Al desaparecer la autocorrelaciÃ³n ficticia, la magnitud de Moran I disminuye, aunque suele seguir siendo estadÃ­sticamente significativa.

En sÃ­ntesis, la opciÃ³n A proporciona una medida mÃ¡s conservadora y fidedigna de la dependencia espacial; la opciÃ³n B se conserva solo para reproducir resultados antiguos, a costa de introducir un sesgo positivo.

```{r moranI_Qdens}

## â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
##  MORAN I global  (variable log_Qdens)
## â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Vector respuesta (orden idÃ©ntico a nb_queen / lw_queen) ---------------------
y_raw <- modelo_sf$log_Qdens

# â”€â”€ OPCIÃ“N A  â”€ vÃ¡lida si â‰¥ 1 vecino con dato no-NA  -------------------------
vecinos_con_dato <- sapply(nb_queen, \(nb) any(!is.na(y_raw[nb])))
keep_idx <- which(!is.na(y_raw) & vecinos_con_dato)          # â† activa Ã©sta

# â”€â”€ OPCIÃ“N B  â”€ versiÃ³n heredada (franja horizontal)  ------------------------
# keep_idx <- which(!is.na(y_raw) & spdep::card(nb_queen) > 0)

# Convierto a vector lÃ³gico (requisito de subset.listw) -----------------------
keep_log <- seq_along(nb_queen) %in% keep_idx                # TRUE / FALSE

# Sub-lista de pesos coherente ------------------------------------------------
lw_sub <- spdep::subset.listw(lw_queen, subset = keep_log, zero.policy = TRUE)

# Moran I global --------------------------------------------------------------
moran_raw <- spdep::moran.test(
  y_raw[keep_log],          # valores solo para las UCS â€œvÃ¡lidasâ€
  listw       = lw_sub,
  zero.policy = TRUE
)
print(moran_raw)

# Guardamos estadÃ­stico y p-valor para anotaciÃ³n posterior --------------------
I_global <- round(moran_raw$estimate[["Moran I statistic"]], 4)
p_global <- signif(moran_raw$p.value, 3)


```

Con la misma sub-matriz de pesos (lw_sub) se calculan los indicadores locales (Ii, p-valor, lag espacial) y se categoriza cada UCS como High-High, Low-Low, High-Low, Low-High o No sig. (p > 0.05).

Moran I es un promedio ponderado de todas las covarianzas espaciales; tiende a â€œdiluirâ€ focos muy fuertes cuando hay Ã¡reas extensas sin patrÃ³n. El Ii (LISA) estandariza cada polÃ­gono por la varianza local â€“por eso puede alcanzar valores de 8-12 incluso cuando I â‰ˆ 0.08. Con un nÃºmero de UCS grande, un I pequeÃ±o puede ser altamente significativo (p â‰ª 0.01) y justificar la bÃºsqueda de clÃºsteres locales.

```{r LISA}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# LISA LOCAL â€• detecta focos de autocorrelaciÃ³n
# Input  :  y_raw      â€“ vector completo de log_Qdens
#           keep_log   â€“ vector lÃ³gico (TRUE = UCS con dato y â‰¥1 vecino vÃ¡lido)
#           lw_sub     â€“ sub-matriz de pesos (fila-estandarizada) para keep_log
# Output :  modelo_sf_s recibe Ii_raw Â· p_Ii_raw Â· lag_raw Â· cluster_raw
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

## 1 â–¸ EstadÃ­sticos locales de Moran (Ii, p-value, etc.)
##    - Usamos sÃ³lo los polÃ­gonos â€œvÃ¡lidosâ€ â†’ y_raw[keep_log]
lisa_raw <- spdep::localmoran(y_raw[keep_log], lw_sub)
# lisa_raw tiene 5 columnas, pero el nombre exacto del p-value
# varÃ­a entre versiones de *spdep* (â€œPr(z > 0)â€, â€œPr(z > 0.0)â€, â€¦)

## 2 â–¸ Copiamos resultados a la tabla espacial -----------------
##    - Creamos columnas â€œvacÃ­asâ€ (NA) para luego rellenar
modelo_sf_s <- modelo_sf_s %>%
  mutate(
    Ii_raw   = NA_real_,   # valor del indicador local
    p_Ii_raw = NA_real_,   # p-value (se rellena abajo)
    lag_raw  = NA_real_    # promedio ponderado de vecinos
  )

##    - Ãndices lÃ³gicos â†’ posiciones numÃ©ricas para asignar
modelo_sf_s$Ii_raw [keep_log] <- lisa_raw[, "Ii"]

# --- p-value: busca la columna que empieza por â€œPr(â€ -------------------------

# spdep â‰¤1.2 usa nombre "Pr(z > 0)"; versiones â‰¥1.3 cambian a "Pr(z > 0.0)"
p_col <- grep("^Pr\\(", colnames(lisa_raw))        # devuelve Ã­ndice(s)
if (length(p_col) != 1) p_col <- 5                 # respaldo: 5.Âª columna

modelo_sf_s$p_Ii_raw[keep_log] <- lisa_raw[, p_col]

# --- Lag espacial (Wy) -------------------------------------------------------
modelo_sf_s$lag_raw[keep_log]  <- spdep::lag.listw(
  lw_sub, y_raw[keep_log]
)

## 3 â–¸ ClasificaciÃ³n en clÃºsteres LISA --------------------------
##    - Umbrales global/lag calculados sobre las mismas filas vÃ¡lidas
global_mean <- mean(y_raw[keep_log],               na.rm = TRUE)
lag_mean    <- mean(modelo_sf_s$lag_raw[keep_log], na.rm = TRUE)

modelo_sf_s <- modelo_sf_s %>%
  mutate(
    # Etiqueta segÃºn cuadrante y significancia (p â‰¤ 0.05)
    cluster_raw = case_when(
      log_Qdens > global_mean & lag_raw > lag_mean & p_Ii_raw <= 0.05 ~ "High-High",
      log_Qdens < global_mean & lag_raw < lag_mean & p_Ii_raw <= 0.05 ~ "Low-Low",
      log_Qdens > global_mean & lag_raw < lag_mean & p_Ii_raw <= 0.05 ~ "High-Low",
      log_Qdens < global_mean & lag_raw > lag_mean & p_Ii_raw <= 0.05 ~ "Low-High",
      TRUE ~ "No sig."   # no significativo o sin vecinos con dato
    )
  )


```

Cerramos la exploraciÃ³n descriptiva con tres paneles: (i) diagrama de dispersiÃ³n Moran local, (ii) mapa de clusters LISA y (iii) mapa de los valores Ii. Esta visualizaciÃ³n resume de forma intuitiva dÃ³nde se concentran los nÃºcleos y valles de diversidad antes de modelar explÃ­citamente la dependencia espacial.

Los ejes del scatter se centran en las medias globales (xÌ„, áº)Para grÃ¡ficas el clÃ¡sico origen (0, 0) bastarÃ­a estandarizar log_Qdens (z-score) y volver a calcular el lag: entonces xÌ„ = áº = 0.

```{r visualizacion_LISA}


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  VISUALIZACIÃ“N Â· TRIPANEL LISA
#  (a) Scatter local (Moran)    Â· anota I global
#  (b) Mapa de clÃºsteres LISA   Â· cinco clases + â€œNo sig.â€
#  (c) Mapa de valores Ii       Â· magnitud del estadÃ­stico local
#  *solo UCS con keep_log = TRUE*
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

## 1 â–¸ Data-frames ------------------------------------------------------------
plot_df    <- modelo_sf_s[keep_log, ]                     # mapas
scatter_df <- plot_df |> filter(!is.na(cluster_raw))      # scatter

## 2 â–¸ Paletas y niveles ------------------------------------------------------
pal_cont <- paletteer::paletteer_c("grDevices::Zissou 1", 100)
col_lisa <- c("High-High" = pal_cont[90],
              "Low-Low"   = pal_cont[10],
              "High-Low"  = pal_cont[70],
              "Low-High"  = pal_cont[30],
              "No sig."   = "grey90")

niveles <- c("No sig.", "Low-Low", "Low-High", "High-Low", "High-High")
scatter_df <- scatter_df |> mutate(
  cluster_raw = factor(cluster_raw, levels = niveles),
  cluster_sig = ifelse(cluster_raw == "No sig.", "No", "SÃ­")   # helper Î±
)

## 3 â–¸ Referencias para el scatter -------------------------------------------
x0 <- mean(scatter_df$log_Qdens, na.rm = TRUE)
y0 <- mean(scatter_df$lag_raw ,  na.rm = TRUE)
txt_I <- sprintf("Global Moran I = %.4f (p = %.3g)", I_global, p_global)

## 4 â–¸ (a) Scatter Moran local -----------------------------------------------
p_scatter <- ggplot(scatter_df,
                    aes(log_Qdens, lag_raw,
                        colour = cluster_raw,
                        alpha  = cluster_sig)) +          # Î± sÃ³lo a sig.
  geom_point(size = .9) +
  scale_alpha_manual(values = c("No" = 1, "SÃ­" = .85), guide = "none") +
  geom_smooth(method = "lm", se = FALSE,
              colour = "black", linewidth = .45) +
  geom_hline(yintercept = y0, linetype = "dashed", colour = "grey60") +
  geom_vline(xintercept = x0, linetype = "dashed", colour = "grey60") +
  scale_colour_manual(values = col_lisa, name = "ClÃºster LISA", drop = FALSE) +
  guides(colour = guide_legend(override.aes = list(size = 3))) +
  annotate("text", x = -Inf, y =  Inf, hjust = -0.05, vjust = 1.1,
           label = txt_I, size = 3.5, fontface = "italic") +
  labs(x = expression(log[10]~"(Q / Ã¡rea)"),   # â† tilde ~ corregida
       y = "Lag espacial (WÂ·y)",
       title = "DispersiÃ³n Moran local") +
  theme_minimal(base_size = 11) +
  theme(legend.position = "right")

## 5 â–¸ (b) Mapa de clÃºsteres --------------------------------------------------
p_clusters <- ggplot(plot_df) +
  geom_sf(aes(fill = cluster_raw), colour = NA) +
  scale_fill_manual(values = col_lisa, name = "ClÃºster LISA",
                    drop = FALSE, na.translate = FALSE) +
  labs(title = "Mapa de clÃºsteres LISA") +
  theme_minimal(base_size = 11)

## 6 â–¸ (c) Mapa de Ii ---------------------------------------------------------
p_ii <- ggplot(plot_df) +
  geom_sf(aes(fill = Ii_raw), colour = NA) +
  scale_fill_viridis_c(name = "Ii local",
                       option = "magma", direction = -1,
                       na.value = "white") +
  labs(title = "Mapa de valores Ii") +
  theme_minimal(base_size = 11)

## 7 â–¸ Tripanel ---------------------------------------------------------------
p_lisa_tripanel <- (p_scatter | p_clusters | p_ii) +
  patchwork::plot_layout(guides = "auto")

ggsave(
  here::here("Figures", "moran_local_tripanel_new.png"),
  plot   = p_lisa_tripanel,
  width  = 15, height = 5, dpi = 300
)

p_lisa_tripanel     # se muestra en el cuaderno



```


### 3.3 Conclusiones del anÃ¡lisis de autocorrelaciÃ³n espacial

El Moran I global (â‰ˆ 0,08; p < 0,001) revela dependencia espacial positiva, aunque de magnitud moderada. El valor se atenÃºa porque la autocorrelaciÃ³n se concentra en focos concretos: extensas zonas Low-Low, caracterizadas por pedodiversidad homogÃ©nea, y corredores Low-High / High-Low que seÃ±alan transiciones nÃ­tidas entre dominios contrastantes. Los nÃºcleos High-High son escasos y localizados, lo que reduce el promedio global.

La aparente discrepancia entre la nube de puntos High-Low del scatter-plot y su escasa superficie en el mapa se explica por la escala: muchos polÃ­gonos High-Low son parches pequeÃ±Ã­simos. En el scatter cada uno aporta un punto; en el mapa, al dibujarlos sin borde y a escala nacional, quedan casi invisibles. Inversamente, los Low-High suelen ser franjas anchas en los mÃ¡rgenes de los dominios Low-Low y, por eso, ocupan mÃ¡s Ã¡rea cartogrÃ¡fica pero generan menos puntos.

Esta heterogeneidad espacial justifica aÃ±adir un componente espacial en los modelos posteriores.

Para eliminar autocorrelaciÃ³n de los residuos basta un SAR-error / SEM.

Si se desea cuantificar la varianza espacial o incorporar jerarquÃ­as (p. ej. era geolÃ³gica), son preferibles un CAR (INLA) o modelos mixtos con efecto espacial aleatorio.

## 4. Modelo de dependencia y heterogeneidad espacial INLA

```{r}


## â”€â”€ 1 Â· Sub-vecindad sin islas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# keep_log  â†’  vector lÃ³gico ya definido (dato â‰  NA  y  â‰¥1 vecino con dato)
nb_sub <- spdep::subset.nb(nb_queen, subset = keep_log)            # lista vecinos
if (any(spdep::card(nb_sub) == 0)) stop("aÃºn quedan polÃ­gonos sin vecinos")

## â”€â”€ 2 Â· Matriz de adyacencia binaria 0/1 (estilo = â€œBâ€) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
A_bin <- spdep::nb2mat(nb_sub, style = "B", zero.policy = TRUE)    # OK
# filas/columnas = n_valid  (â‰ˆ 41 500, no 43 384)

## â”€â”€ 3 Â· Fichero graph que INLA lee automÃ¡ticamente â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# (opciÃ³n mÃ¡s segura cuando la matriz es grande)
queen_graph <- "queen_sub.graph"
nb2INLA(file = queen_graph, nb = nb_sub)    # crea el .graph en disco

## â”€â”€ 4 Â· Ãndice numÃ©rico de polÃ­gono dentro del subconjunto â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
modelo_sf$id_poly <- NA_integer_
modelo_sf$id_poly[keep_log] <- seq_len(sum(keep_log))   # 1â€¦n_valid

## â”€â”€ 5 Â· FÃ³rmula BYM2 (dependencia + heterogeneidad) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
formula_bym2 <- log_Qdens ~
  dem_media_z + pendiente_media_z +
  lst_media_z + precip_media_z +
  log_dem_cv_z + log_pendiente_cv_z +
  log_lst_cv_temporal_z + log_precip_cv_temporal_z +
  f(era_geo, model = "iid") +                # intercepto por era
  f(id_poly, model = "bym2",
            graph = queen_graph,
            scale.model = TRUE)

## â”€â”€ 6 Â· Ajuste con INLA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
fit_bym2 <- INLA::inla(
  formula_bym2,
  data   = as.data.frame(modelo_sf)[keep_log, ],   # mismo subconjunto
  family = "gaussian",
  control.predictor = list(compute = TRUE),
  control.compute   = list(dic = TRUE, waic = TRUE)
)


```

### 4.1 Resumen general

```{r}

# tabla compacta (DIC, WAIC, logLik)
fit_bym2$dic$dic
fit_bym2$waic$waic
summary(fit_bym2)$cpu    # tiempos y nÂº de iteraciones


```
QuÃ© falta para saber si el modelo es â€œbuenoâ€
â€“ Comparar DIC/WAIC con un modelo de referencia (sin tÃ©rmino BYM2 Ã³ sin covariables).
â€“ Ver si los residuos han perdido autocorrelaciÃ³n.
â€“ Explorar la importancia relativa del campo espacial y de las covariables.

### 4.2 Efectos fijos beta

```{r}

fix_tab <- fit_bym2$summary.fixed[, c("mean","0.025quant","0.975quant")]
print(round(fix_tab, 3))

# forestâ€plot rÃ¡pido
ggplot(as.data.frame(fix_tab), aes(x = mean, y = rownames(fix_tab)))+
  geom_point()+
  geom_errorbarh(aes(xmin = `0.025quant`, xmax = `0.975quant`), height = .1)+
  labs(x = "Î²  (posterior mean Â±95% CI)", y = NULL)+
  theme_minimal()

```

Tabla de coeficientes

```{r}
tabla_beta <- fit_bym2$summary.fixed |>
  tibble::rownames_to_column("Covariable") |>
  dplyr::select(
    Covariable,
    `Media`  = mean,
    `SD`     = sd,
    `2.5 %`  = `0.025quant`,
    `97.5 %` = `0.975quant`
  )

tabla_beta
```

Los coeficientes del modelo BYM2 confirman que la pedodiversidad ( logâ‚â‚€ Q/Ãrea) responde de forma marcada a la topografÃ­a, mÃ¡s moderadamente al clima medio y casi de forma marginal a la variabilidad temporal de ese clima.

El intercepto posterior (â€“3.12 Â± 0.01) fija la referencia cuando todas las covariables estandarizadas valen cero. Es decir, el intercepto es el nivel base de pedodiversidad para un polÃ­gono con valores promedio de elevaciÃ³n, pendiente, temperatura, precipitaciÃ³n y de sus coeficientes de variaciÃ³n, dentro del gradiente montaÃ±oso de la zona de estudio.

Entre las variables de â€œintensidadâ€ topogrÃ¡fica, la elevaciÃ³n media exhibe el efecto mÃ¡s marcado. El coeficiente para dem_media_z es Î² â‰ˆ âˆ’0.95; como la variable estÃ¡ estandarizada, una unidad-z equivale a 1 045 m (desviaciÃ³n estÃ¡ndar de la elevaciÃ³n en el conjunto). AsÃ­, al ascender â‰ˆ 1 kilÃ³metro respecto de la media muestral la densidad logarÃ­tmica de pedodiversidad (logâ‚â‚€ Q/Ãrea) disminuye en 0.95 unidades. En escala lineal, ese cambio implica que la diversidad esperada se reduce a â‰ˆ 11 % de la observada al nivel inferior (10^âˆ’0.95 â‰ˆ 0.11).

La pendiente media mantiene un efecto positivo (Î² â‰ˆ +0,20). Una desviaciÃ³n estÃ¡ndar en la serie equivale a â‰ˆ 7,8 Â° de inclinaciÃ³n (Ïƒ = 7,76 Â°). Elevar la pendiente en ese rango incrementa la densidad logarÃ­tmica en 0,20 unidades; al deshacer la transformaciÃ³n (10^0,20 â‰ˆ 1,58) esto significa multiplicar el valor original por 1,58, lo que representa un 58 % mÃ¡s â€’ porque un factor 1,58 equivale a (1,58â€“1)Ã—100=58% de aumento. Los taludes mÃ¡s inclinados, al parecer, sostienen mosaicos edÃ¡ficos mÃ¡s ricos, probablemente por la diversidad de microambientes, el drenaje rÃ¡pido y la continua incorporaciÃ³n de materiales coluviales.

La temperatura superficial (LST media) mantiene un efecto negativo de magnitud intermedia (â€“0.33): Ã¡reas mÃ¡s cÃ¡lidas â€”en promedio las mÃ¡s bajas y hÃºmedasâ€” son algo menos diversas que los pisos termo-mesotermos. La precipitaciÃ³n media anual aporta un coeficiente positivo pequeÃ±o (0.06) cuya banda de credibilidad, aunque estrecha, sugiere un papel secundario pero real en sostener procesos edafogenÃ©ticos variados allÃ­ donde el rÃ©gimen hÃ­drico es mÃ¡s constante.

Los indicadores de heterogeneidad espacial (CV de DEM y de pendiente) divergen con claridad. El log-CV de elevaciÃ³n, que resume el relieve interno de cada polÃ­gono, registra el segundo efecto en magnitud (â€“1.16): a mayor irregularidad altitudinal dentro de la UCS disminuye la diversidad neta, seÃ±al de que dominios topogrÃ¡ficos muy quebrados concentran tipos de suelo especÃ­ficos y excluyen otros. En cambio, la variaciÃ³n relativa de la pendiente (Î² â‰ˆ 0.38) actÃºa en sentido opuesto: mosaicos dominados por abruptos y lomas suaves alternantes incrementan la riqueza, quizÃ¡ al habilitar nichos fisionÃ³micamente contrastantes a escala fina.

Las proxies de variabilidad climÃ¡tica interanual (CV temporal de LST y de precipitaciÃ³n) muestran efectos mucho mÃ¡s tenues. Un aumento de una desviaciÃ³n estÃ¡ndar en la variabilidad tÃ©rmica eleva la pedodiversidad sÃ³lo en 0.036 unidades log, mientras que el efecto de la variabilidad pluviomÃ©trica apenas supera el umbral de credibilidad (IC 95 % incluye cero en el tercer decimal). En sÃ­ntesis, la seÃ±al climÃ¡tica estÃ¡ dominada por el nivel medio y no por su fluctuaciÃ³n temporal.

Estas magnitudes ya estÃ¡n libres del componente espacial â€”gracias a la estructura BYM2â€”, por lo que pueden leerse como efectos â€œpurosâ€. El resultado subraya la primacÃ­a del contexto geomorfolÃ³gico (elevaciÃ³n, relieve interno y gradientes) sobre el clima en la configuraciÃ³n de nÃºcleos y valles de pedodiversidad a escala nacional.



### 4.3 Hiper-parÃ¡metros BYM2

phi â‰ˆ porciÃ³n estructurada;
prec â‰¡ 1/varianza.

```{r}
hyper <- fit_bym2$summary.hyperpar
print(round(hyper, 4))         # incluye phi, prec.iid, prec.spatial

```
El campo BYM2 reparte la variabilidad residual en tres ingredientes:
(1) el ruido independiente Îµ,
(2) la dependencia espacial estructurada (CAR) entre polÃ­gonos vecinos, y
(3) la heterogeneidad no estructurada asociada a la era geolÃ³gica.

INLA informa precisiones (1 / varianza). A mÃ¡s precisiÃ³n, menor varianza.

Ruido independiente.
La â€œPrecision for the Gaussian observationsâ€ es â‰ˆ 1.23, lo que implica una varianza de â‰ˆ 0.81. Es decir, despuÃ©s de restar efectos fijos y aleatorios el modelo deja poca dispersiÃ³n sin explicar: la mayor parte del patrÃ³n de log Qdens queda capturada.  La cifra 0,81 es la varianza que queda (en unidades de log QdensÂ²) despuÃ©s de que el modelo ha tenido en cuenta covariables + tÃ©rminos aleatorios. Para saber â€œquÃ© porcentaje hemos explicadoâ€ habrÃ­a que compararla con la varianza de log Qdens antes de modelar (â‰ˆ ÏƒÂ²_total). Ese cociente aÃºn no lo hemos calculado.

Varianza espacial total.
La â€œPrecision for id_polyâ€ es â‰ˆ 1.86 â†’ varianza â‰ˆ 0.54. Existe variaciÃ³n espacial apreciable, pero no desmesurada; buena parte del contraste entre polÃ­gonos se recoge en este tÃ©rmino.

Mezcla Ï† del BYM2.
El parÃ¡metro phi es â‰ˆ 0.88 (en una escala 0â€“1). Un Ï† tan alto indica que alrededor del 88 % de la varianza espacial se debe a similitud entre vecinos (el componente CAR); solo un 12 % corresponde a heterogeneidad local no correlacionada (iid). Dicho de otro modo, el mosaico de clÃºsteres que vimos con LISA obedece mayormente a dependencia estructurada, no a â€œruidoâ€ puntual.

Heterogeneidad entre eras geolÃ³gicas.
La â€œPrecision for era_geoâ€ supera 5 Ã— 10â´, lo que se traduce en una varianza de apenas 2 Ã— 10â»âµ. PrÃ¡cticamente cero: una vez controladas las covariables, pertenecer a una era u otra no aÃ±ade dispersiÃ³n apreciable. El tÃ©rmino puede eliminarse sin afectar el ajuste.

En sÃ­ntesis: el ajuste confirma que la autocorrelaciÃ³n espacial es imprescindible para describir la pedodiversidad (Ï† alto y varianza CAR distinta de cero), mientras que el factor â€œera geolÃ³gicaâ€ es irrelevante y podrÃ­a omitirse. El componente iid residual es moderado, seÃ±al de que las covariables han capturado la mayor parte de la seÃ±al.

### 4.4 Efectos aleatorios - intercepto por era

```{r}

era_tab <- fit_bym2$summary.random$era_geo[, c("ID","mean","0.025quant","0.975quant")]

era_tab

```

Los interceptos aleatorios estimados para cada era geolÃ³gica son prÃ¡cticamente nulos y todos sus intervalos creÃ­bles al 95 % abarcan el cero:

Cz: â€“0.0015 (â€“0.0225 ; +0.0153)

Mz: +0.0011 (â€“0.0158 ; +0.0209)

NA: â€“0.0019 (â€“0.0315 ; +0.0173)

Ptz: â€“0.0039 (â€“0.0381 ; +0.0128)

Pz: +0.0049 (â€“0.0115 ; +0.0412)

En otras palabras, ninguna era muestra un desplazamiento sistemÃ¡tico de la pedodiversidad, una vez controlada la combinaciÃ³n de covariables topogrÃ¡ficas, climÃ¡ticas y de variabilidad. La dispersiÃ³n restante entre polÃ­gonos ya se explica por la componente espacial CAR y por el ruido iid; el nivel â€œeraâ€ aÃ±ade informaciÃ³n despreciable. Esto respalda la conclusiÃ³n extraÃ­da del hiper-parÃ¡metro de precisiÃ³n: el tÃ©rmino aleatorio por era puede omitirse en modelos simplificados sin sacrificar ajuste ni interpretaciÃ³n.

### 4.5 Campo espacial BYM2

Las columnas 1 : n_valid de fit_bym2$summary.random$id_poly devuelven media y error std por polÃ­gono.
AÃ±Ã¡delas al sf y mÃ¡palas:

```{r}

ran_spat <- fit_bym2$summary.random$id_poly
modelo_sf$u_mean   <- NA_real_
modelo_sf$u_sd     <- NA_real_
modelo_sf$u_mean[keep_log] <- ran_spat$mean
modelo_sf$u_sd  [keep_log] <- ran_spat$sd

ggplot(modelo_sf) +
  geom_sf(aes(fill = u_mean), colour = NA) +
  scale_fill_viridis_c(option = "magma", direction = -1) +
  labs(title = "Campo espacial BYM2 â€“ media posterior", fill = "mean(u)") +
  theme_minimal()

```

Los valores positivos del tÃ©rmino espacial ui â€”los tonos pÃºrpura â€“ negro de la figuraâ€” son mucho mÃ¡s extensos y visibles que los clÃºsteres High-High del mapa LISA. Esto no es una contradicciÃ³n: LISA solo etiqueta como High-High a los polÃ­gonos donde tanto el valor propio como el promedio de los vecinos son altos y, en nuestro caso, esos nÃºcleos son minÃºsculos y muy dispersos, de modo que casi pasan desapercibidos.

El efecto ui  del modelo BYM2, en cambio, resume la parte de la variaciÃ³n que queda sin explicar tras ajustar todas las covariables y la proyecta sobre cada polÃ­gono combinando dependencia (CAR) + heterogeneidad local. Al no exigir que los vecinos compartan exactamente la misma magnitud â€”basta con que la estructura espacial coherente mejore el ajuste globalâ€” el campo resultante puede delinear zonas continuas con residuos positivos allÃ­ donde LISA solo detectaba puntos aislados.

En la prÃ¡ctica: Tonos pÃºrpuraâ€“negro (ui > 0) indican polÃ­gonos cuyas densidades de pedodiversidad siguen siendo mayores de lo previsto incluso despuÃ©s de controlar altura, pendiente, clima y variabilidad; se concentran en los flancos andinos y Ã¡reas de fuerte compartimentaciÃ³n, por lo que aparecen como manchas bien visibles aunque LISA no los catalogara como High-High.

Tonos amarillos (ui < 0) coinciden, como ya se observÃ³, con los grandes clÃºsteres Low-Low de LISA en valles interandinos y llanuras: allÃ­ la diversidad es sistemÃ¡ticamente menor que la esperada.AsÃ­, el mapa de ui
completa la lectura exploratoria del LISA: confirma las depresiones de baja diversidad y revela, con mayor continuidad espacial, los focos donde la pedodiversidad supera las predicciones ambientales aunque esos focos no formen clÃºsteres High-High segÃºn la definiciÃ³n estricta de LISA.

*FAlta: hasta ahora no hemos contrastado numÃ©ricamente el campo ui  ni los clÃºsteres LISA con una capa que delinee valles interandinos, llanuras o flancos de cordillera. La frase que seÃ±alas no procede de un cÃ¡lculo mostrado en el cuaderno, sino de una inf erencia visual al superponer mentalmente el mapa sobre la geografÃ­a de Colombia (cordilleras al centro-occidente, valles del Cauca y Magdalena en sus depresiones, Llanos al oriente).POdrÃ­a sobreponerse a hillshade.

Para que esa afirmaciÃ³n sea vÃ¡lida en el manuscrito necesitamos comprobarla de forma reproducible. Hay dos formas rÃ¡pidas de hacerlo:

1. Cruce espacial con una capa fisiogrÃ¡fica
Descargar un shapefile vectorial con las principales unidades fisiogrÃ¡ficas (cordilleras, valles interandinos, llanuras, piedemontes).

Hacer un st_join() con modelo_sf y calcular, para cada unidad, la media de ui  y la proporciÃ³n de polÃ­gonos en cada categorÃ­a LISA.

### 4.6 PredicciÃ³n y residuos

mostrar dÃ³nde el modelo BYM2 todavÃ­a sobre- o sub-estima la pedodiversidad. Se parte de la media posterior 
Î¼i  y se calcula un residuo estilo Pearson


```{r}

## â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
##  Mapa de residuos posteriores  (observado â€“ media posterior)
## â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# 1 â–¸ extrae media y sd de la lista de predicciones de INLA
pred_df <- fit_bym2$summary.fitted[ , c("mean","sd")]

modelo_sf$mu_post <- modelo_sf$mu_sd <- NA_real_
modelo_sf$mu_post[keep_log] <- pred_df$mean   # media posterior
modelo_sf$mu_sd  [keep_log] <- pred_df$sd     # desv. tÃ­p. posterior

# 2 â–¸ residuo posterior (escala original â€’log10-)
modelo_sf$resid <- modelo_sf$log_Qdens - modelo_sf$mu_post

# 3 â–¸ paleta Zissou 1 (continua) adaptada como diverging
pal_cont <- paletteer::paletteer_c("grDevices::Zissou 1", 100)
pal_div  <- c(rev(pal_cont[10:1]), pal_cont[11:90])   # ~amarillo-blanco-pÃºrpura

# 4 â–¸ mapa
p_resid <- ggplot(modelo_sf) +
  geom_sf(aes(fill = resid), colour = NA) +
  scale_fill_gradientn(
    colours = pal_div,
    limits  = c(-4, 4),          # recorta colas extremas a Â±4 u log
    oob     = scales::squish,    # valores fuera â†’ extremo de la paleta
    name    = "resid"
  ) +
  labs(title = "Residuos posteriores (observado â€“ media posterior)") +
  theme_minimal()

p_resid            # se renderiza en el cuaderno


```
amarillo â†’ naranjas ( > 0 )
indican sub-predicciÃ³n: la pedodiversidad observada es mayor que la estimada por el modelo;

verde-azules ( < 0 )
seÃ±alan sobre-predicciÃ³n: la pedodiversidad observada es menor que la estimada;

corresponden a ajuste satisfactorio.

La dispersiÃ³n de colores y la ausencia de bandas extensas de un mismo signo muestran que no persisten patrones espaciales sistemÃ¡ticos. Un test de Moran sobre los residuos (FALTA),  respalda??? que la autocorrelaciÃ³n residual es insignificante y que el tÃ©rmino espacial BYM2 cumpliÃ³ su funciÃ³n de absorber la dependencia.


Esos parches azulados del extremo sur â€• donde el modelo sobre-predice la pedodiversidad â€• encajan bastante bien con varias limitaciones prÃ¡cticas de la cartografÃ­a nacional de suelos en la Amazonia y el piedemonte andino-amazÃ³nico:

Cobertura de muestreo muy desigual
Los inventarios histÃ³ricos (IGAC, IGAC-FAO, proyectos departamentales) apenas pasaban por los grandes rÃ­os navegables y las pistas de colonizaciÃ³n. En muchos de esos polÃ­gonos sÃ³lo existe el mapeo fotointerpretado de los aÃ±os 1970-1980, con muy pocos perfiles descritos in situ.
Consecuencia: la cuenta de taxones (Q) estÃ¡ infra-estimada; el modelo, al asumir que los datos reflejan la realidad, la â€œcorrigeâ€ al alza â†’ residuos negativos intensos (azules).

Complejidad edÃ¡fica sub-muestreada
El relieve de colinas disectadas, terrazas y abanicos aluviales jÃ³venes genera suelos muy contrastantes a escalas < 1 km (Fluvisoles, Acrisoles, Plinthosoles, Histosoles localizados). Esa heterogeneidad real no aparece si el polÃ­gono se levantÃ³ con un Ãºnico taxÃ³n â€œdominanteâ€.
Resultado: predicciÃ³n basada en topografÃ­a/clima (que â€œesperaâ€ un mosaico diverso) > diversidad observada â†’ residuo negativo.

Acceso fÃ­sico y situaciÃ³n de orden pÃºblico
Comunidades sin carreteras estables y, durante aÃ±os, presencia de actores armados dificultaron el trabajo de campo sistemÃ¡tico. Las zonas que mencionas coincidieron con poca o nula actualizaciÃ³n catastral/agrÃ³noma.
Efecto: sesgo de observaciÃ³n mÃ¡s que un fallo real del modelo ambiental.

QuÃ© hacer con esa seÃ±al
Variable de esfuerzo de muestreo
Incorporar un offset (o covariable) que contabilice nÃºmero de perfiles/ha o distancia media a vÃ­as fluviales y carreteras podrÃ­a reducir el sesgo.

ValidaciÃ³n cruzada espacial estratificada
Separar esas Ã¡reas â€œpoco accesiblesâ€ como fold independiente mostrarÃ­a si el sobre-ajuste es grave o se debe sobre todo a carencia de datos.

Trabajo de campo dirigido
Si tu objetivo final es un mapa operativo, priorizar muestreos en esos polÃ­gonos azulados mejorarÃ¡ tanto la base de datos como la capacidad predictiva.

En sÃ­ntesis, los azules intensos no significan que el modelo â€œse equivoqueâ€ por mala especificaciÃ³n, sino que extrapola hacia regiones sub-levadas. El diagnÃ³stico es Ãºtil: seÃ±ala exactamente dÃ³nde la estrategia de muestreo histÃ³rica dejÃ³ lagunas que conviene subsanar.

## 5. Lo que falta

Definiendo ya los productos bÃ¡sicos de cada capaâ€”estadÃ­sticos globales, betas, hiper-parÃ¡metros, efectos aleatorios y residuosâ€”quedan varias comprobaciones y extensiones que conviene completar para que el apartado de resultados y discusiÃ³n sea sÃ³lido y coherente con los objetivos del artÃ­culo.

En el bloque (1) ajuste global sÃ³lo hemos reportado DIC, WAIC y tiempos de cÃ³mputo. Falta contrastar esos indicadores con un modelo de referencia sin tÃ©rmino espacial (BYM2 reducido a Ï† = 0) o, al menos, con el SAR-error frequentista que intentamos al principio. Esa comparaciÃ³n cuantifica la ganancia real de incorporar la estructura CAR. TambiÃ©n queda por revisar los â€œmezcla-betaâ€ internos de INLA (el parÃ¡metro Îº que controla la precisiÃ³n de la aproximaciÃ³n de Laplace) para descartar problemas de convergencia; basta con fit_bym2$internal.summary$max.gradient y inla.emarginal sobre el log-marginal likelihood.

En la capa (2) efectos fijos ya tienes los intervalos creÃ­bles y su interpretaciÃ³n, pero sigue pendiente evaluar la colinealidad residual entre covariables (p. ej. con las VIF sobre la matriz X estandarizada) y, sobre todo, representar la contribuciÃ³n relativa de cada bloque de variables (intensidad, variedad y variabilidad) al RÂ² marginal de la respuesta. Eso se obtiene con la descomposiciÃ³n de varianza â€œvariance partitioningâ€ de INLA (inla.qmarginal) o con la versiÃ³n de partR2 adaptada a LGMs.

Para (3) hiper-parÃ¡metros BYM2 ya discutimos magnitud y significado, pero falta la prueba de sensibilidad a los priors. INLA permite re-ajustar el modelo con penalised-complexity priors algo mÃ¡s informativos para la mezcla Ï† y para la precisiÃ³n espacial; comparar las nuevas posteriors con las actuales mostrarÃ¡ si las conclusiones dependen del prior inercial que viene por defecto. AdemÃ¡s, conviene mapear la ratio ÏƒÂ²_s / ÏƒÂ²_total para ilustrar visualmente quÃ© fracciÃ³n de varianza absorbe el campo estructurado.

En (4) efectos aleatorios ya tienes la tabla de interceptos por era y el mapa de uáµ¢. Faltan dos pasos. Primero, la banda de incertidumbre: un segundo mapa con la desviaciÃ³n tÃ­pica posterior (u_sd) y un breve comentario sobre dÃ³nde el modelo â€œsabe menosâ€. Segundo, enlazar cuantitativamente ese campo con la LISA original. El contraste formal es un test de correlaciÃ³n espacial entre uáµ¢ y los Ii localesâ€”moran.mc(u_mean, lw_sub)â€”que permitirÃ¡ afirmar con nÃºmeros, no sÃ³lo con inspecciÃ³n ocular, que el BYM2 efectivamente absorbe la mayor parte de los focos Low-Low.

Por Ãºltimo, en (5) predicciÃ³n y residuos ya generaste el mapa de residuos. Falta el diagnÃ³stico estadÃ­stico: histograma o QQ-plot de los residuos normalizados frente a la distribuciÃ³n normal, un correlograma de Moran sobre esos residuos (mismo script que usaste para el correlograma LISA) y, opcionalmente, la curva PIT (Probability Integral Transform) que INLA calcula con control.compute = list(cpo = TRUE). Si el correlograma no muestra p-valores < 0.05 y el QQ-plot no presenta colas gruesas, podrÃ¡s afirmar que el modelo deja la estructura espacial prÃ¡cticamente eliminada y que la suposiciÃ³n gaussiana es aceptable.

Con esas verificaciones adicionalesâ€”comparaciÃ³n con modelos nulos, particiÃ³n de varianza por bloques, sensibilidad a priors, incertidumbre del campo uáµ¢ y diagnÃ³stico exhaustivo de residuosâ€”la secciÃ³n de resultados cubrirÃ¡ todos los puntos crÃ­ticos del modelo BYM2 y cerrarÃ¡ el cÃ­rculo que iniciaste con el anÃ¡lisis global y local de autocorrelaciÃ³n.
