"e1071", #estadisticas
"dplyr", #procesamiento de data frames
"ggplot2",  #graficación
"patchwork", #mosaicos gráficos
"wesanderson", #paleta de colores
"qs" #escribir y leer rápidamente objetos R
)
)
#Paleta de colores
pal <- wes_palette("Zissou1", 100, type = "continuous")
# Ajusta tamaño de letra para todo e lscript
theme(base_size = 14)
ucs_rao_sf <- ucs_rao_sf |>
#Se descartan NAs debido a polígonos que no son suelos
tidyr::drop_na(Q) |>
mutate(
# se deja un mínimo diferente de cero para trabajar con logaritmos
Q = case_when(Q == 0 ~ 1e-6, TRUE ~ Q),
#Se calcula la densidad de Q
Qdens = Q / AREA_HA,
log_Qdens = log(Qdens),  # suma pequeño valor para evitar log(0)
log_Qdens01 = (log_Qdens - min(log_Qdens, na.rm = TRUE)) /
(max(log_Qdens, na.rm = TRUE) - min(log_Qdens, na.rm = TRUE))
)
# Se transforma a df para usar en skimr
ucs_rao_df <- sf::st_drop_geometry(ucs_rao_sf)
# Variables de interés
vars <- c("Q", "AREA_HA", "Qdens", "log_Qdens")
# Estadística descriptiva rápida
skimr::skim(ucs_rao_df[, vars])
# Tabla resumen con CV, sesgo y curtosis
stats_summary <- vars |>
setNames(vars) |>
lapply(function(var) {
x <- ucs_rao_df[[var]]
x <- x[!is.na(x)]
data.frame(
variable = var,
cv        = sd(x) / mean(x),
skewness  = skewness(x, type = 2),     # tipo 2: Fisher (media = 0 para normal)
kurtosis  = kurtosis(x, type = 2) - 3  # restar 3 para curtosis "exceso"
)
}) |>
bind_rows()
print(stats_summary)
# Crear columnas transformadas
ucs_rao_sf <- ucs_rao_sf |>
mutate(
Q_squared = Q^2,
log_A = log10(AREA_HA),
log_Qdens = log10(Qdens)
)
# Tukey para Q_squared
q25_q2 <- quantile(ucs_rao_sf$Q_squared, 0.25, na.rm = TRUE)
q75_q2 <- quantile(ucs_rao_sf$Q_squared, 0.75, na.rm = TRUE)
iqr_q2 <- q75_q2 - q25_q2
tukey_low_q2  <- q25_q2 - 1.5 * iqr_q2
tukey_high_q2 <- q75_q2 + 1.5 * iqr_q2
# Tukey para log_A
q25_la <- quantile(ucs_rao_sf$log_A, 0.25, na.rm = TRUE)
q75_la <- quantile(ucs_rao_sf$log_A, 0.75, na.rm = TRUE)
iqr_la <- q75_la - q25_la
tukey_low_la  <- q25_la - 1.5 * iqr_la
tukey_high_la <- q75_la + 1.5 * iqr_la
# Tukey para log_Qdens
q25_lqd <- quantile(ucs_rao_sf$log_Qdens, 0.25, na.rm = TRUE)
q75_lqd <- quantile(ucs_rao_sf$log_Qdens, 0.75, na.rm = TRUE)
iqr_lqd <- q75_lqd - q25_lqd
tukey_low_lqd  <- q25_lqd - 1.5 * iqr_lqd
tukey_high_lqd <- q75_lqd + 1.5 * iqr_lqd
# Crear columnas transformadas
ucs_rao_sf <- ucs_rao_sf |>
mutate(
Q_squared = Q^2,
log_A = log10(AREA_HA),
log_Qdens = log10(Qdens)
)
# Tukey para Q_squared
q25_q2 <- quantile(ucs_rao_sf$Q_squared, 0.25, na.rm = TRUE)
q75_q2 <- quantile(ucs_rao_sf$Q_squared, 0.75, na.rm = TRUE)
iqr_q2 <- q75_q2 - q25_q2
tukey_low_q2  <- q25_q2 - 1.5 * iqr_q2
tukey_high_q2 <- q75_q2 + 1.5 * iqr_q2
#Tukey par aA
q25_a <- quantile(ucs_rao_sf$AREA_HA, 0.25, na.rm = TRUE)
q75_a <- quantile(ucs_rao_sf$AREA_HA, 0.75, na.rm = TRUE)
iqr_a <- q75_a - q25_a
tukey_low_a  <- q25_a - 1.5 * iqr_a
tukey_high_a <- q75_a + 1.5 * iqr_a
# Tukey para log_A
q25_la <- quantile(ucs_rao_sf$log_A, 0.25, na.rm = TRUE)
q75_la <- quantile(ucs_rao_sf$log_A, 0.75, na.rm = TRUE)
iqr_la <- q75_la - q25_la
tukey_low_la  <- q25_la - 1.5 * iqr_la
tukey_high_la <- q75_la + 1.5 * iqr_la
# Tukey para log_Qdens
q25_lqd <- quantile(ucs_rao_sf$log_Qdens, 0.25, na.rm = TRUE)
q75_lqd <- quantile(ucs_rao_sf$log_Qdens, 0.75, na.rm = TRUE)
iqr_lqd <- q75_lqd - q25_lqd
tukey_low_lqd  <- q25_lqd - 1.5 * iqr_lqd
tukey_high_lqd <- q75_lqd + 1.5 * iqr_lqd
# Distribución de Q
p_Q <- ggplot(ucs_rao_sf, aes(Q)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(xintercept = tukey_low_q,  linetype = "dashed", color = "gray30") +
geom_vline(xintercept = tukey_high_q, linetype = "dashed", color = "gray30") +
#geom_vline(aes(xintercept = quantile(Q, 0.95, na.rm = TRUE)), linetype = "dashed") alternativa q.95
labs(title = "Distribución de Q", y = "Frecuencia", x = "Q")
# Crear columnas transformadas
ucs_rao_sf <- ucs_rao_sf |>
mutate(
Q_squared = Q^2,
log_A = log10(AREA_HA),
log_Qdens = log10(Qdens)
)
# Tukey limits for Q
q25_q <- quantile(ucs_rao_sf$Q, 0.25, na.rm = TRUE)
q75_q <- quantile(ucs_rao_sf$Q, 0.75, na.rm = TRUE)
iqr_q <- q75_q - q25_q
tukey_low_q  <- q25_q - 1.5 * iqr_q
tukey_high_q <- q75_q + 1.5 * iqr_q
# Tukey para Q_squared
q25_q2 <- quantile(ucs_rao_sf$Q_squared, 0.25, na.rm = TRUE)
q75_q2 <- quantile(ucs_rao_sf$Q_squared, 0.75, na.rm = TRUE)
iqr_q2 <- q75_q2 - q25_q2
tukey_low_q2  <- q25_q2 - 1.5 * iqr_q2
tukey_high_q2 <- q75_q2 + 1.5 * iqr_q2
#Tukey par aA
q25_a <- quantile(ucs_rao_sf$AREA_HA, 0.25, na.rm = TRUE)
q75_a <- quantile(ucs_rao_sf$AREA_HA, 0.75, na.rm = TRUE)
iqr_a <- q75_a - q25_a
tukey_low_a  <- q25_a - 1.5 * iqr_a
tukey_high_a <- q75_a + 1.5 * iqr_a
# Tukey para log_A
q25_la <- quantile(ucs_rao_sf$log_A, 0.25, na.rm = TRUE)
q75_la <- quantile(ucs_rao_sf$log_A, 0.75, na.rm = TRUE)
iqr_la <- q75_la - q25_la
tukey_low_la  <- q25_la - 1.5 * iqr_la
tukey_high_la <- q75_la + 1.5 * iqr_la
# Tukey limits for Qdens
q25_qd <- quantile(ucs_rao_sf$Qdens, 0.25, na.rm = TRUE)
q75_qd <- quantile(ucs_rao_sf$Qdens, 0.75, na.rm = TRUE)
iqr_qd <- q75_qd - q25_qd
tukey_low_qd  <- q25_qd - 1.5 * iqr_qd
tukey_high_qd <- q75_qd + 1.5 * iqr_qd
# Tukey para log_Qdens
q25_lqd <- quantile(ucs_rao_sf$log_Qdens, 0.25, na.rm = TRUE)
q75_lqd <- quantile(ucs_rao_sf$log_Qdens, 0.75, na.rm = TRUE)
iqr_lqd <- q75_lqd - q25_lqd
tukey_low_lqd  <- q25_lqd - 1.5 * iqr_lqd
tukey_high_lqd <- q75_lqd + 1.5 * iqr_lqd
# Distribución de Q
p_Q <- ggplot(ucs_rao_sf, aes(Q)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(xintercept = tukey_low_q,  linetype = "dashed", color = "gray30") +
geom_vline(xintercept = tukey_high_q, linetype = "dashed", color = "gray30") +
#geom_vline(aes(xintercept = quantile(Q, 0.95, na.rm = TRUE)), linetype = "dashed") alternativa q.95
labs(title = "Distribución de Q", y = "Frecuencia", x = "Q")
#Distribución de Q con escala de potencia
p_Qpot <- ggplot(ucs_rao_sf, aes(x = Q_squared)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(xintercept = tukey_low_q2,  linetype = "dashed", color = "gray30") +
geom_vline(xintercept = tukey_high_q2, linetype = "dashed", color = "gray30") +
scale_x_continuous(trans = "identity", name = "Q") +
labs(title = expression("Distribución en escala " * Q^2), y = "Frecuencia")
#Dsistribución de áreas
p_A <- ggplot(ucs_rao_sf, aes(AREA_HA)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(xintercept = tukey_low_a,  linetype = "dashed", color = "gray30") +
geom_vline(xintercept = tukey_high_a, linetype = "dashed", color = "gray30") +
labs(title = "Distribución de A", y = "Frecuencia", x = "A (Ha)")
#Distribución de áreas con escala de log10
p_logA <- ggplot(ucs_rao_sf, aes(x = log_A)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black" , .width = c(0.5, 0.9)) +
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(xintercept = tukey_low_la,  linetype = "dashed", color = "gray30") +
geom_vline(xintercept = tukey_high_la, linetype = "dashed", color = "gray30") +
scale_x_continuous(
name = "A (Ha)",
breaks = trans_breaks("identity", function(x) x),
labels = label_comma()
) +
labs(title = "Distribución de log(A)", y = "Frecuencia")
# Para renderizar el documento
knitr::opts_chunk$set(echo = TRUE)
# Para cargar librerias se verifica pacman
if ("pacman" %in% installed.packages() == FALSE) install.packages("pacman")
# Se cargan las librerias
pacman::p_load(char = c(
"here", #manejo de rutas
"skimr", #estadisticas
"e1071", #estadisticas
"sf", #manipulación de dats espaciales
"dplyr", #procesamiento de data frames
"ggplot2",  #graficación
"ggdist", #graficar distribuciones
"scales", #escalas
"ggforce", #transformaciones especiales
"patchwork", #mosaicos gráficos
"wesanderson", #paleta de colores
"qs" #escribir y leer rápidamente objetos R
)
)
#Paleta de colores
pal <- wes_palette("Zissou1", 100, type = "continuous")
# Ajusta tamaño de letra para todo e lscript
theme(base_size = 14)
# Distribución de Q
p_Q <- ggplot(ucs_rao_sf, aes(Q)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(xintercept = tukey_low_q,  linetype = "dashed", color = "gray30") +
geom_vline(xintercept = tukey_high_q, linetype = "dashed", color = "gray30") +
#geom_vline(aes(xintercept = quantile(Q, 0.95, na.rm = TRUE)), linetype = "dashed") alternativa q.95
labs(title = "Distribución de Q", y = "Frecuencia", x = "Q")
#Distribución de Q con escala de potencia
p_Qpot <- ggplot(ucs_rao_sf, aes(x = Q_squared)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(xintercept = tukey_low_q2,  linetype = "dashed", color = "gray30") +
geom_vline(xintercept = tukey_high_q2, linetype = "dashed", color = "gray30") +
scale_x_continuous(trans = "identity", name = "Q") +
labs(title = expression("Distribución en escala " * Q^2), y = "Frecuencia")
#Dsistribución de áreas
p_A <- ggplot(ucs_rao_sf, aes(AREA_HA)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(xintercept = tukey_low_a,  linetype = "dashed", color = "gray30") +
geom_vline(xintercept = tukey_high_a, linetype = "dashed", color = "gray30") +
labs(title = "Distribución de A", y = "Frecuencia", x = "A (Ha)")
#Distribución de áreas con escala de log10
p_logA <- ggplot(ucs_rao_sf, aes(x = log_A)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black" , .width = c(0.5, 0.9)) +
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(xintercept = tukey_low_la,  linetype = "dashed", color = "gray30") +
geom_vline(xintercept = tukey_high_la, linetype = "dashed", color = "gray30") +
scale_x_continuous(
name = "A (Ha)",
breaks = trans_breaks("identity", function(x) x),
labels = label_comma()
) +
labs(title = "Distribución de log(A)", y = "Frecuencia")
#Distribución de Q/A
p_Qdens <- ggplot(ucs_rao_sf, aes(Qdens)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(xintercept = tukey_low_qd,  linetype = "dashed", color = "gray30") +
geom_vline(xintercept = tukey_high_qd, linetype = "dashed", color = "gray30") +
labs(title = "Distribución de Q/A", y = "Frecuencia", x = "Q/A")
#Distribución de Q/ A con esala log10
p_logQdens <- ggplot(ucs_rao_sf, aes(x = log_Qdens)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black" , .width = c(0.5, 0.9)) +
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(xintercept = tukey_low_lqd,  linetype = "dashed", color = "gray30") +
geom_vline(xintercept = tukey_high_lqd, linetype = "dashed", color = "gray30") +
scale_x_continuous(
name = "Q/A",
breaks = trans_breaks("identity", function(x) x),
labels = label_scientific()
) +
labs(title = "Distribución de log(Q/A)", y = "Frecuencia")
# Exporta mosaico
p_mosaico_Qdens <-  p_Q + p_Qpot + p_A + p_logA + p_Qdens + p_logQdens + plot_layout(ncol = 2, widths = c(1, 1))
p_mosaico_Qdens
#guarda el último gráfico generado
ggsave(here("Figures","histogramas_Qdens.png"), width = 9, height = 9, dpi = 350)
View(ucs_rao_sf)
#Mapa simple de Q
p_mapa_Q <- ggplot(ucs_rao_sf) +
geom_sf(aes(fill = Q), color = NA) +
scale_fill_gradientn(colours = pal, na.value = "white") +
labs(title = "Mapa de Q", fill = "Q") +
theme_minimal()
#Mapa  Q con escala potencia 2
p_mapa_Qpot <- ggplot(ucs_rao_sf) +
geom_sf(aes(fill = Q), color = NA) +
scale_fill_gradientn(
colours = pal,
na.value = "white",
trans = ggforce::power_trans(2)  # This will apply Qdens^2 to the fill scale
) +
labs(title = expression("Mapa en escala " * Q^2), fill = "Q") +
theme_minimal()
#Mapa simple de áreas
#p_mapa_A <- ggplot(ucs_rao_sf) +
#  geom_sf(aes(fill = AREA_HA), color = NA) +
#  scale_fill_viridis_c() +
#  labs(title = "Mapa de A", fill = "A (Ha)") +
#  theme_minimal()
#Mapa de áreas con escala log10
#p_mapa_logA <- ggplot(ucs_rao_sf) +
#  geom_sf(aes(fill = AREA_HA), color = NA) +
#  scale_fill_viridis_c(trans = "log10") +
#  labs(title = "Mapa de log(A)", fill = "A (Ha)") +
#  theme_minimal()
#Mapa de Q/A simple
p_mapa_Qdens <- ggplot(ucs_rao_sf) +
geom_sf(aes(fill = Qdens), color = NA) +
scale_fill_gradientn(colours = pal, na.value = "white") +
labs(title = "Mapa de Q/A", fill = "Q/A") +
theme_minimal()
#Mapa de Q/A en escala log1'
p_mapa_logQdens <- ggplot(ucs_rao_sf) +
geom_sf(aes(fill = Qdens), color = NA) +
scale_fill_gradientn(
colours = pal,
na.value = "white",
trans = "log10",
breaks = scales::trans_breaks("log10", function(x) 10^x)
) +
labs(title = "Mapa en escala log(Q/A)", fill = "Q/A") +
theme_minimal()
p_mapas_Qdens <- p_mapa_Q + p_mapa_Qpot+ p_mapa_Qdens + p_mapa_logQdens + plot_layout(ncol = 2, widths = c(1, 1))
p_mapas_Qdens
#guarda el último gráfico generado
ggsave(here("Figures","mapas_Qdens.png"), width = 8, height = 9, dpi = 350)
rm(list=ls())
# Para renderizar el documento
knitr::opts_chunk$set(echo = TRUE)
# Para cargar librerias se verifica pacman
if ("pacman" %in% installed.packages() == FALSE) install.packages("pacman")
# Se cargan las librerias
pacman::p_load(char = c(
"here", #manejo de rutas
"sf", #manipulación de dats espaciales
"skimr", #estadisticas
"e1071", #estadisticas
"dplyr", #procesamiento de data frames
"ggplot2",  #graficación
"patchwork", #mosaicos gráficos
"wesanderson", #paleta de colores
"qs" #escribir y leer rápidamente objetos R
)
)
#Paleta de colores
pal <- wes_palette("Zissou1", 100, type = "continuous")
# Ajusta tamaño de letra para todo e lscript
theme(base_size = 14)
#Carga local sin internet
ruta_ucs_rao <- here::here("Data", "OUTPUT_rao_andina_sf.qs")
ucs_rao_sf <- qs::qread(ruta_ucs_rao) #lectura local
# Corre script externo
#source(here::here("Scripts", "carga_ucs_procesadas_qs.R"), encoding = "UTF-8")
head(ucs_rao_sf)
ucs_rao_sf <- ucs_rao_sf |>
#Se descartan NAs debido a polígonos que no son suelos
tidyr::drop_na(Q) |>
mutate(
# se deja un mínimo diferente de cero para trabajar con logaritmos
Q = case_when(Q == 0 ~ 1e-6, TRUE ~ Q),
#Se calcula la densidad de Q
Qdens = Q / AREA_HA,
log_Qdens = log(Qdens),  # suma pequeño valor para evitar log(0)
log_Qdens01 = (log_Qdens - min(log_Qdens, na.rm = TRUE)) /
(max(log_Qdens, na.rm = TRUE) - min(log_Qdens, na.rm = TRUE))
)
# Se transforma a df para usar en skimr
ucs_rao_df <- sf::st_drop_geometry(ucs_rao_sf)
# Variables de interés
vars <- c("Q", "AREA_HA", "Qdens", "log_Qdens")
# Estadística descriptiva rápida
skimr::skim(ucs_rao_df[, vars])
# Tabla resumen con CV, sesgo y curtosis
stats_summary <- vars |>
setNames(vars) |>
lapply(function(var) {
x <- ucs_rao_df[[var]]
x <- x[!is.na(x)]
data.frame(
variable = var,
cv        = sd(x) / mean(x),
skewness  = skewness(x, type = 2),     # tipo 2: Fisher (media = 0 para normal)
kurtosis  = kurtosis(x, type = 2) - 3  # restar 3 para curtosis "exceso"
)
}) |>
bind_rows()
print(stats_summary)
umbral <- quantile(ucs_rao_sf$log_Qdens, 0.95, na.rm = TRUE) # percentil 90
ucs_rao_sf <- ucs_rao_sf %>%
mutate(hotspot = as.integer(log_Qdens >= umbral))
umbral <- quantile(ucs_rao_sf$log_Qdens, 0.95, na.rm = TRUE) # percentil 90
ucs_rao_sf <- ucs_rao_sf %>%
mutate(Qdens_hot = as.integer(log_Qdens >= umbral))
View(ucs_rao_sf)
rm(list=ls())
# Para renderizar el documento
knitr::opts_chunk$set(echo = TRUE)
# Para cargar librerias se verifica pacman
if ("pacman" %in% installed.packages() == FALSE) install.packages("pacman")
# Se cargan las librerias
pacman::p_load(char = c(
"here", #manejo de rutas
"sf", #manipulación de dats espaciales
"skimr", #estadisticas
"e1071", #estadisticas
"dplyr", #procesamiento de data frames
"ggplot2",  #graficación
"patchwork", #mosaicos gráficos
"wesanderson", #paleta de colores
"qs" #escribir y leer rápidamente objetos R
)
)
#Paleta de colores
pal <- wes_palette("Zissou1", 100, type = "continuous")
# Ajusta tamaño de letra para todo e lscript
theme(base_size = 14)
#Carga local sin internet
ruta_ucs_rao <- here::here("Data", "OUTPUT_rao_andina_sf.qs")
ucs_rao_sf <- qs::qread(ruta_ucs_rao) #lectura local
# Corre script externo
#source(here::here("Scripts", "carga_ucs_procesadas_qs.R"), encoding = "UTF-8")
head(ucs_rao_sf)
ucs_rao_sf <- ucs_rao_sf |>
#Se descartan NAs debido a polígonos que no son suelos
tidyr::drop_na(Q) |>
mutate(
# se deja un mínimo diferente de cero para trabajar con logaritmos
Q = case_when(Q == 0 ~ 1e-6, TRUE ~ Q),
#Se calcula la densidad de Q
Qdens = Q / AREA_HA,
log_Qdens = log(Qdens),  # suma pequeño valor para evitar log(0)
log_Qdens01 = (log_Qdens - min(log_Qdens, na.rm = TRUE)) /
(max(log_Qdens, na.rm = TRUE) - min(log_Qdens, na.rm = TRUE))
)
# Se transforma a df para usar en skimr
ucs_rao_df <- sf::st_drop_geometry(ucs_rao_sf)
# Variables de interés
vars <- c("Q", "AREA_HA", "Qdens", "log_Qdens")
# Estadística descriptiva rápida
skimr::skim(ucs_rao_df[, vars])
# Tabla resumen con CV, sesgo y curtosis
stats_summary <- vars |>
setNames(vars) |>
lapply(function(var) {
x <- ucs_rao_df[[var]]
x <- x[!is.na(x)]
data.frame(
variable = var,
cv        = sd(x) / mean(x),
skewness  = skewness(x, type = 2),     # tipo 2: Fisher (media = 0 para normal)
kurtosis  = kurtosis(x, type = 2) - 3  # restar 3 para curtosis "exceso"
)
}) |>
bind_rows()
print(stats_summary)
View(ucs_rao_df)
#Se definen dos umbrales
umbral95 <- quantile(ucs_rao_sf$log_Qdens, 0.95, na.rm = TRUE) # percentil 95
umbral90 <- quantile(ucs_rao_sf$log_Qdens, 0.90, na.rm = TRUE) # percentil 90
ucs_rao_sf <- ucs_rao_sf |>
mutate(Qdens_hot95 = case_when(log_Qdens >= umbral95 ~  "Si", TRUE ~ "No"))
#Se definen dos umbrales
umbral95 <- quantile(ucs_rao_sf$log_Qdens, 0.95, na.rm = TRUE) # percentil 95
umbral90 <- quantile(ucs_rao_sf$log_Qdens, 0.90, na.rm = TRUE) # percentil 90
ucs_rao_sf <- ucs_rao_sf |>
mutate(Qdens_hot95 = case_when(log_Qdens >= umbral95 ~  "Si", TRUE ~ "No"),
hotspot = as.integer(log_Qdens >= umbral95))
#Se definen dos umbrales
umbral95 <- quantile(ucs_rao_sf$log_Qdens, 0.95, na.rm = TRUE) # percentil 95
umbral05 <- quantile(ucs_rao_sf$log_Qdens, 0.05, na.rm = TRUE) # percentil 5
ucs_rao_sf <- ucs_rao_sf |>
mutate(Qdens_hot95 = as.integer(log_Qdens >= umbral95),
Qdens_cold5 = as.integer(log_Qdens >= umbral05)) # returna 1 = TRUE, 0 = FALSE
# Para renderizar el documento
knitr::opts_chunk$set(echo = TRUE)
# Para cargar librerias se verifica pacman
if ("pacman" %in% installed.packages() == FALSE) install.packages("pacman")
# Se cargan las librerias
pacman::p_load(char = c(
"here", #manejo de rutas
"sf", #manipulación de dats espaciales
"skimr", #estadisticas
"e1071", #estadisticas
"dplyr", #procesamiento de data frames
"ggplot2",  #graficación
"patchwork", #mosaicos gráficos
"wesanderson", #paleta de colores
"qs" #escribir y leer rápidamente objetos R
)
)
#Paleta de colores
pal <- wes_palette("Zissou1", 100, type = "continuous")
# Ajusta tamaño de letra para todo e lscript
theme(base_size = 14)
#Carga local sin internet
ruta_ucs_rao <- here::here("Data", "OUTPUT_rao_andina_sf.qs")
ucs_rao_sf <- qs::qread(ruta_ucs_rao) #lectura local
# Para renderizar el documento
knitr::opts_chunk$set(echo = TRUE)
# Para cargar librerias se verifica pacman
if ("pacman" %in% installed.packages() == FALSE) install.packages("pacman")
# Se cargan las librerias
pacman::p_load(char = c(
"here", #manejo de rutas
"sf", #manipulación de dats espaciales
"skimr", #estadisticas
"e1071", #estadisticas
"dplyr", #procesamiento de data frames
"ggplot2",  #graficación
"patchwork", #mosaicos gráficos
"wesanderson", #paleta de colores
"qs" #escribir y leer rápidamente objetos R
)
)
#Paleta de colores
pal <- wes_palette("Zissou1", 100, type = "continuous")
# Ajusta tamaño de letra para todo e lscript
theme(base_size = 14)
