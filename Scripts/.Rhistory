linetype = "dashed") +
scale_x_continuous(trans = ggforce::power_trans(2),
name = "Q") +
labs(title = expression("Distribución de " * Q^2), y = "Frecuencia")
#Dsistribución de áreas
p_A <- ggplot(ucs_rao_sf, aes(AREA_HA)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
geom_vline(aes(xintercept = quantile(AREA_HA, 0.95, na.rm = TRUE)),
linetype = "dashed") +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
labs(title = "Distribución de A", y = "Frecuencia", x = "A (Ha)")
#Distribución de áreas con escala de log10
p_logA <- ggplot(ucs_rao_sf, aes(AREA_HA)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black" , .width = c(0.5, 0.9)) +
geom_vline(aes(xintercept = quantile(AREA_HA, 0.95, na.rm = TRUE)),
linetype = "dashed") +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
scale_x_continuous(trans = "log10",
breaks = trans_breaks("log10", function(x) 10^x),
labels = label_comma()) +
labs(title = "Distribución de log(A)", y = "Frecuencia", x = "A (Ha)")
#Distribución de Q/A
p_Q_A <- ggplot(ucs_rao_sf, aes(Q_A)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black" , .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(aes(xintercept = quantile(Q_A, 0.95, na.rm = TRUE)),
linetype = "dashed") +
labs(title = "Distribución de Q/A", y = "Frecuencia", x = "Q/A")
#Distribución de Q/ A con esala log10
p_logQ_A <- ggplot(ucs_rao_sf, aes(Q_A)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black" , .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(aes(xintercept = quantile(Q_A, 0.95, na.rm = TRUE)),
linetype = "dashed") +
geom_vline(aes(xintercept = quantile(Q_A, 0.05, na.rm = TRUE)),
linetype = "dashed") +
scale_x_continuous(trans = "log10",
breaks = trans_breaks("log10", function(x) 10^x),
labels = label_scientific()) +
labs(title = "Distribución de log(Q/A)", y = "Frecuencia", x = "Q/A")
# Exporta mosaico
p_mosaico_Q_A <-  p_Q + p_Qpot + p_A + p_logA + p_Q_A + p_logQ_A + plot_layout(ncol = 2, widths = c(1, 1))
p_mosaico_Q_A
#guarda el último gráfico generado
ggsave(here("Figures","histogramas_q_a.png"), width = 10, height = 10, dpi = 350)
# Distribución de Q
p_Q <- ggplot(ucs_rao_sf, aes(Q)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(aes(xintercept = quantile(Q, 0.95, na.rm = TRUE)),
linetype = "dashed") +
geom_vline(aes(xintercept = quantile(Q_A, 0.05, na.rm = TRUE)),
linetype = "dashed") +
labs(title = "Distribución de Q", y = "Frecuencia", x = "Q")
#Distribución de Q con escala de potencia
p_Qpot <- ggplot(ucs_rao_sf, aes(x = Q)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(aes(xintercept = quantile(Q, 0.95, na.rm = TRUE)),
linetype = "dashed") +
scale_x_continuous(trans = ggforce::power_trans(2),
name = "Q") +
labs(title = expression("Distribución de " * Q^2), y = "Frecuencia")
#Dsistribución de áreas
p_A <- ggplot(ucs_rao_sf, aes(AREA_HA)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
geom_vline(aes(xintercept = quantile(AREA_HA, 0.95, na.rm = TRUE)),
linetype = "dashed") +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
labs(title = "Distribución de A", y = "Frecuencia", x = "A (Ha)")
#Distribución de áreas con escala de log10
p_logA <- ggplot(ucs_rao_sf, aes(AREA_HA)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black" , .width = c(0.5, 0.9)) +
geom_vline(aes(xintercept = quantile(AREA_HA, 0.95, na.rm = TRUE)),
linetype = "dashed") +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
scale_x_continuous(trans = "log10",
breaks = trans_breaks("log10", function(x) 10^x),
labels = label_comma()) +
labs(title = "Distribución de log(A)", y = "Frecuencia", x = "A (Ha)")
#Distribución de Q/A
p_Q_A <- ggplot(ucs_rao_sf, aes(Q_A)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black" , .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(aes(xintercept = quantile(Q_A, 0.95, na.rm = TRUE)),
linetype = "dashed") +
labs(title = "Distribución de Q/A", y = "Frecuencia", x = "Q/A")
#Distribución de Q/ A con esala log10
p_logQ_A <- ggplot(ucs_rao_sf, aes(Q_A)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black" , .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(aes(xintercept = quantile(Q_A, 0.95, na.rm = TRUE)),
linetype = "dashed") +
geom_vline(aes(xintercept = quantile(Q_A, 0.05, na.rm = TRUE)),
linetype = "dashed") +
scale_x_continuous(trans = "log10",
breaks = trans_breaks("log10", function(x) 10^x),
labels = label_scientific()) +
labs(title = "Distribución de log(Q/A)", y = "Frecuencia", x = "Q/A")
# Exporta mosaico
p_mosaico_Q_A <-  p_Q + p_Qpot + p_A + p_logA + p_Q_A + p_logQ_A + plot_layout(ncol = 2, widths = c(1, 1))
p_mosaico_Q_A
#guarda el último gráfico generado
ggsave(here("Figures","histogramas_q_a.png"), width = 10, height = 10, dpi = 350)
# Distribución de Q
p_Q <- ggplot(ucs_rao_sf, aes(Q)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(aes(xintercept = quantile(Q, 0.95, na.rm = TRUE)),
linetype = "dashed") +
geom_vline(aes(xintercept = quantile(Q_A, 0.05, na.rm = TRUE)),
linetype = "dashed") +
labs(title = "Distribución de Q", y = "Frecuencia", x = "Q")
#Distribución de Q con escala de potencia
p_Qpot <- ggplot(ucs_rao_sf, aes(x = Q)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(aes(xintercept = quantile(Q, 0.95, na.rm = TRUE)),
linetype = "dashed") +
scale_x_continuous(trans = ggforce::power_trans(2),
name = "Q") +
labs(title = expression("Distribución de " * Q^2), y = "Frecuencia")
#Dsistribución de áreas
p_A <- ggplot(ucs_rao_sf, aes(AREA_HA)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
labs(title = "Distribución de A", y = "Frecuencia", x = "A (Ha)")
#Distribución de áreas con escala de log10
p_logA <- ggplot(ucs_rao_sf, aes(AREA_HA)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black" , .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
scale_x_continuous(trans = "log10",
breaks = trans_breaks("log10", function(x) 10^x),
labels = label_comma()) +
labs(title = "Distribución de log(A)", y = "Frecuencia", x = "A (Ha)")
#Distribución de Q/A
p_Q_A <- ggplot(ucs_rao_sf, aes(Q_A)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black" , .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(aes(xintercept = quantile(Q_A, 0.95, na.rm = TRUE)),
linetype = "dashed") +
labs(title = "Distribución de Q/A", y = "Frecuencia", x = "Q/A")
#Distribución de Q/ A con esala log10
p_logQ_A <- ggplot(ucs_rao_sf, aes(Q_A)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black" , .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(aes(xintercept = quantile(Q_A, 0.95, na.rm = TRUE)),
linetype = "dashed") +
geom_vline(aes(xintercept = quantile(Q_A, 0.05, na.rm = TRUE)),
linetype = "dashed") +
scale_x_continuous(trans = "log10",
breaks = trans_breaks("log10", function(x) 10^x),
labels = label_scientific()) +
labs(title = "Distribución de log(Q/A)", y = "Frecuencia", x = "Q/A")
# Exporta mosaico
p_mosaico_Q_A <-  p_Q + p_Qpot + p_A + p_logA + p_Q_A + p_logQ_A + plot_layout(ncol = 2, widths = c(1, 1))
p_mosaico_Q_A
#guarda el último gráfico generado
ggsave(here("Figures","histogramas_q_a.png"), width = 10, height = 10, dpi = 350)
# Distribución de Q
p_Q <- ggplot(ucs_rao_sf, aes(Q)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(aes(xintercept = quantile(Q, 0.95, na.rm = TRUE)),
linetype = "dashed") +
geom_vline(aes(xintercept = quantile(Q_A, 0.05, na.rm = TRUE)),
linetype = "dashed") +
labs(title = "Distribución de Q", y = "Frecuencia", x = "Q")
#Distribución de Q con escala de potencia
p_Qpot <- ggplot(ucs_rao_sf, aes(x = Q)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(aes(xintercept = quantile(Q, 0.95, na.rm = TRUE)),
linetype = "dashed") +
scale_x_continuous(trans = ggforce::power_trans(2),
name = "Q") +
labs(title = expression("Distribución de " * Q^2), y = "Frecuencia")
#Dsistribución de áreas
p_A <- ggplot(ucs_rao_sf, aes(AREA_HA)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
labs(title = "Distribución de A", y = "Frecuencia", x = "A (Ha)")
#Distribución de áreas con escala de log10
p_logA <- ggplot(ucs_rao_sf, aes(AREA_HA)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black" , .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
scale_x_continuous(trans = "log10",
breaks = trans_breaks("log10", function(x) 10^x),
labels = label_comma()) +
labs(title = "Distribución de log(A)", y = "Frecuencia", x = "A (Ha)")
#Distribución de Q/A
p_Q_A <- ggplot(ucs_rao_sf, aes(Q_A)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black" , .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(aes(xintercept = quantile(Q_A, 0.95, na.rm = TRUE)),
linetype = "dashed") +
labs(title = "Distribución de Q/A", y = "Frecuencia", x = "Q/A")
#Distribución de Q/ A con esala log10
p_logQ_A <- ggplot(ucs_rao_sf, aes(Q_A)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black" , .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(aes(xintercept = quantile(Q_A, 0.95, na.rm = TRUE)),
linetype = "dashed") +
geom_vline(aes(xintercept = quantile(Q_A, 0.05, na.rm = TRUE)),
linetype = "dashed") +
scale_x_continuous(trans = "log10",
breaks = trans_breaks("log10", function(x) 10^x),
labels = label_scientific()) +
labs(title = "Distribución de log(Q/A)", y = "Frecuencia", x = "Q/A")
# Exporta mosaico
p_mosaico_Q_A <-  p_Q + p_Qpot + p_A + p_logA + p_Q_A + p_logQ_A + plot_layout(ncol = 2, widths = c(1, 1))
p_mosaico_Q_A
#guarda el último gráfico generado
ggsave(here("Figures","histogramas_q_a.png"), width = 9, height = 9, dpi = 350)
#Mapa simple de Q
p_mapa_Q <- ggplot(ucs_rao_sf) +
geom_sf(aes(fill = Q), color = NA) +
scale_fill_gradientn(colours = pal, na.value = "white") +
labs(title = "Mapa de Q", fill = "Q") +
theme_minimal()
#Mapa  Q con escala potencia 2
p_mapa_Qpot <- ggplot(ucs_rao_sf) +
geom_sf(aes(fill = Q), color = NA) +
scale_fill_gradientn(
colours = pal,
na.value = "white",
trans = ggforce::power_trans(2)  # This will apply Q_A^2 to the fill scale
) +
labs(title = expression("Mapa en escala " * Q^2), fill = "Q") +
theme_minimal()
#Mapa simple de áreas
#p_mapa_A <- ggplot(ucs_rao_sf) +
#  geom_sf(aes(fill = AREA_HA), color = NA) +
#  scale_fill_viridis_c() +
#  labs(title = "Mapa de A", fill = "A (Ha)") +
#  theme_minimal()
#Mapa de áreas con escala log10
#p_mapa_logA <- ggplot(ucs_rao_sf) +
#  geom_sf(aes(fill = AREA_HA), color = NA) +
#  scale_fill_viridis_c(trans = "log10") +
#  labs(title = "Mapa de log(A)", fill = "A (Ha)") +
#  theme_minimal()
#Mapa de Q/A simple
p_mapa_QA <- ggplot(ucs_rao_sf) +
geom_sf(aes(fill = Q_A), color = NA) +
scale_fill_gradientn(colours = pal, na.value = "white") +
labs(title = "Mapa de Q/A", fill = "Q/A") +
theme_minimal()
#Mapa de Q/A en escala log1'
p_mapa_logQA <- ggplot(ucs_rao_sf) +
geom_sf(aes(fill = Q_A), color = NA) +
scale_fill_gradientn(
colours = pal,
na.value = "white",
trans = "log10",
breaks = scales::trans_breaks("log10", function(x) 10^x)
) +
labs(title = "Mapa en escala log(Q/A)", fill = "Q/A") +
theme_minimal()
p_mapas_Q_A <- p_mapa_Q + p_mapa_Qpot+ p_mapa_QA + p_mapa_logQA + plot_layout(ncol = 2, widths = c(1, 1))
p_mapas_Q_A
#guarda el último gráfico generado
ggsave(here("Figures","mapas_Q_A.png"), width = 8, height = 9, dpi = 350)
#Se crea una variable Q_A que expresa la densidad de Q
ucs_rao_sf <- ucs_rao_sf |>
tidyr::drop_na(Q) |>
# se deja un mínimo diferente de cero para trabajar con logaritmos
dplyr::mutate(Q = case_when(Q == 0 ~ 0.001, TRUE ~ Q)) |>
dplyr::mutate(Q_A = Q/AREA_HA)
# Se transforma a df para usar en skimr
ucs_rao_df <- sf::st_drop_geometry(ucs_rao_sf)
# Variables de interés
vars <- c("Q", "AREA_HA", "Q_A")
# Estadística descriptiva rápida
skimr::skim(ucs_rao_df[, vars])
# Tabla resumen con CV, sesgo y curtosis
stats_summary <- vars |>
setNames(vars) |>
lapply(function(var) {
x <- ucs_rao_df[[var]]
x <- x[!is.na(x)]
data.frame(
variable = var,
cv        = sd(x) / mean(x),
skewness  = skewness(x, type = 2),     # tipo 2: Fisher (media = 0 para normal)
kurtosis  = kurtosis(x, type = 2) - 3  # restar 3 para curtosis "exceso"
)
}) |>
bind_rows()
# Para renderizar el documento
knitr::opts_chunk$set(echo = TRUE)
# Para cargar librerias se verifica pacman
if ("pacman" %in% installed.packages() == FALSE) install.packages("pacman")
# Se cargan las librerias
pacman::p_load(char = c(
"here", #manejo de rutas
"skimr", #estadisticas
"e1071", #estadisticas
"sf", #manipulación de dats espaciales
"dplyr", #procesamiento de data frames
"ggplot2",  #graficación
"ggdist", #graficar distribuciones
"scales", #escalas
"ggforce", #transformaciones especiales
"patchwork", #mosaicos gráficos
"wesanderson", #paleta de colores
"qs" #escribir y leer rápidamente objetos R
)
)
#Paleta de colores
pal <- wes_palette("Zissou1", 100, type = "continuous")
# Ajusta tamaño de letra para todo e lscript
theme(base_size = 14)
#Se crea una variable Q_A que expresa la densidad de Q
ucs_rao_sf <- ucs_rao_sf |>
tidyr::drop_na(Q) |>
# se deja un mínimo diferente de cero para trabajar con logaritmos
dplyr::mutate(Q = case_when(Q == 0 ~ 0.001, TRUE ~ Q)) |>
dplyr::mutate(Q_A = Q/AREA_HA)
# Se transforma a df para usar en skimr
ucs_rao_df <- sf::st_drop_geometry(ucs_rao_sf)
# Variables de interés
vars <- c("Q", "AREA_HA", "Q_A")
# Estadística descriptiva rápida
skimr::skim(ucs_rao_df[, vars])
# Tabla resumen con CV, sesgo y curtosis
stats_summary <- vars |>
setNames(vars) |>
lapply(function(var) {
x <- ucs_rao_df[[var]]
x <- x[!is.na(x)]
data.frame(
variable = var,
cv        = sd(x) / mean(x),
skewness  = skewness(x, type = 2),     # tipo 2: Fisher (media = 0 para normal)
kurtosis  = kurtosis(x, type = 2) - 3  # restar 3 para curtosis "exceso"
)
}) |>
bind_rows()
print(stats_summary)
#Se crea una variable Q_A que expresa la densidad de Q
ucs_rao_sf <- ucs_rao_sf |>
tidyr::drop_na(Q) |>
# se deja un mínimo diferente de cero para trabajar con logaritmos
dplyr::mutate(Q = case_when(Q == 0 ~ 0.001, TRUE ~ Q),
Q_A = Q/AREA_HA,
log_Q_A = log(Q_A))
# Se transforma a df para usar en skimr
ucs_rao_df <- sf::st_drop_geometry(ucs_rao_sf)
# Variables de interés
vars <- c("Q", "AREA_HA", "Q_A", "log_Q_A")
# Estadística descriptiva rápida
skimr::skim(ucs_rao_df[, vars])
# Tabla resumen con CV, sesgo y curtosis
stats_summary <- vars |>
setNames(vars) |>
lapply(function(var) {
x <- ucs_rao_df[[var]]
x <- x[!is.na(x)]
data.frame(
variable = var,
cv        = sd(x) / mean(x),
skewness  = skewness(x, type = 2),     # tipo 2: Fisher (media = 0 para normal)
kurtosis  = kurtosis(x, type = 2) - 3  # restar 3 para curtosis "exceso"
)
}) |>
bind_rows()
print(stats_summary)
#Se crea una variable Qdens que expresa la densidad de Q
ucs_rao_sf <- ucs_rao_sf |>
tidyr::drop_na(Q) |>
# se deja un mínimo diferente de cero para trabajar con logaritmos
dplyr::mutate(Q = case_when(Q == 0 ~ 0.001, TRUE ~ Q),
Qdens = Q/AREA_HA,
log_Qdens = log(Qdens))
# Se transforma a df para usar en skimr
ucs_rao_df <- sf::st_drop_geometry(ucs_rao_sf)
# Variables de interés
vars <- c("Q", "AREA_HA", "Qdens", "log_Qdens")
# Estadística descriptiva rápida
skimr::skim(ucs_rao_df[, vars])
# Tabla resumen con CV, sesgo y curtosis
stats_summary <- vars |>
setNames(vars) |>
lapply(function(var) {
x <- ucs_rao_df[[var]]
x <- x[!is.na(x)]
data.frame(
variable = var,
cv        = sd(x) / mean(x),
skewness  = skewness(x, type = 2),     # tipo 2: Fisher (media = 0 para normal)
kurtosis  = kurtosis(x, type = 2) - 3  # restar 3 para curtosis "exceso"
)
}) |>
bind_rows()
print(stats_summary)
# Distribución de Q
p_Q <- ggplot(ucs_rao_sf, aes(Q)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(aes(xintercept = quantile(Q, 0.95, na.rm = TRUE)),
linetype = "dashed") +
geom_vline(aes(xintercept = quantile(Qdens, 0.05, na.rm = TRUE)),
linetype = "dashed") +
labs(title = "Distribución de Q", y = "Frecuencia", x = "Q")
#Distribución de Q con escala de potencia
p_Qpot <- ggplot(ucs_rao_sf, aes(x = Q)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(aes(xintercept = quantile(Q, 0.95, na.rm = TRUE)),
linetype = "dashed") +
scale_x_continuous(trans = ggforce::power_trans(2),
name = "Q") +
labs(title = expression("Distribución de " * Q^2), y = "Frecuencia")
#Dsistribución de áreas
p_A <- ggplot(ucs_rao_sf, aes(AREA_HA)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black", .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
labs(title = "Distribución de A", y = "Frecuencia", x = "A (Ha)")
#Distribución de áreas con escala de log10
p_logA <- ggplot(ucs_rao_sf, aes(AREA_HA)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black" , .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
scale_x_continuous(trans = "log10",
breaks = trans_breaks("log10", function(x) 10^x),
labels = label_comma()) +
labs(title = "Distribución de log(A)", y = "Frecuencia", x = "A (Ha)")
#Distribución de Q/A
p_Qdens <- ggplot(ucs_rao_sf, aes(Qdens)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black" , .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(aes(xintercept = quantile(Qdens, 0.95, na.rm = TRUE)),
linetype = "dashed") +
labs(title = "Distribución de Q/A", y = "Frecuencia", x = "Q/A")
#Distribución de Q/ A con esala log10
p_logQdens <- ggplot(ucs_rao_sf, aes(Qdens)) +
ggdist::stat_histinterval(fill = "#56B4E9", color = "black" , .width = c(0.5, 0.9)) +
#"scaled" ajusta la altura a la del histograma
geom_density(aes(y = after_stat(scaled)), color = "#FFD700", size = 0.8) +
geom_vline(aes(xintercept = quantile(Qdens, 0.95, na.rm = TRUE)),
linetype = "dashed") +
geom_vline(aes(xintercept = quantile(Qdens, 0.05, na.rm = TRUE)),
linetype = "dashed") +
scale_x_continuous(trans = "log10",
breaks = trans_breaks("log10", function(x) 10^x),
labels = label_scientific()) +
labs(title = "Distribución de log(Q/A)", y = "Frecuencia", x = "Q/A")
# Exporta mosaico
p_mosaico_Qdens <-  p_Q + p_Qpot + p_A + p_logA + p_Qdens + p_logQdens + plot_layout(ncol = 2, widths = c(1, 1))
p_mosaico_Qdens
#guarda el último gráfico generado
ggsave(here("Figures","histogramas_Qdens.png"), width = 9, height = 9, dpi = 350)
ggplot(ucs_rao_sf |> tidyr::drop_na(), aes(y = Q, x = PAISAJE)) +
stat_histinterval(binwidth = 0.02,
alpha = 0.7,
fill = "#56B4E9",
color = "white",
slab_color = NA) +
geom_boxplot(width = 0.05, outlier.shape = NA, alpha = 0.7, fill = "gray50") +
theme_minimal() +
labs(title = "Distribución de Rao Q por paisaje",
y = "Rao Q", x = "Paisaje") +
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
ggplot(ucs_rao_sf |> tidyr::drop_na(), aes(y = Q, x = CLIMA_1)) +
stat_histinterval(binwidth = 0.02,
alpha = 0.7,
fill = "#56B4E9",
color = "white",
slab_color = NA) +
geom_boxplot(width = 0.05, outlier.shape = NA, alpha = 0.7, fill = "gray50") +
theme_minimal() +
labs(title = "Distribución de Rao Q por clima",
y = "Rao Q", x = "Clima") +
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
ggplot(ucs_rao_sf |> tidyr::drop_na(), aes(y = Q, x = HUMEDAD)) +
stat_histinterval(binwidth = 0.02,
alpha = 0.7,
fill = "#56B4E9",
color = "white",
slab_color = NA) +
geom_boxplot(width = 0.05, outlier.shape = NA, alpha = 0.7, fill = "gray50") +
theme_minimal() +
labs(title = "Distribución de Rao Q por régimen de humedad",
y = "Rao Q", x = "Régimen de humedad") +
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
