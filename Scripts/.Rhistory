pp_centroides_cold <- ppp(
x = coords[,1], y = coords[,2],
window = W,
marks = centroides_sf$lambda_area_cold
)
# Calcula la superficie de intensidad lambda usando kernel smoothing
lambda_im_cold <- density.ppp(
pp_centroides_cold,
weights = marks(pp_centroides_cold),
sigma = bw.diggle(pp_centroides_cold)
)
# Corrige posibles valores negativos residuales a cero
lambda_im_cold[lambda_im_cold < 0] <- 0
#Se visualiza la superficie
plot(lambda_im_cold)
# 1. Crea una columna de marca en cada set
centroides_hot_sf$grupo  <- "hotspot"
centroides_cold_sf$grupo <- "coldspot"
# 2. Une ambos datasets
centroides_bi_sf <- bind_rows(centroides_hot_sf, centroides_cold_sf)
# 3. Extrae las coordenadas
coords_bi <- sf::st_coordinates(centroides_bi_sf)
# 4. Crea el objeto ppp bivariado
pp_bi <- ppp(
x      = coords_bi[,1],
y      = coords_bi[,2],
window = W,
marks  = as.factor(centroides_bi_sf$grupo)
)
#Se puede explorar una ventana mas grande
rmax_bbox2 <- min_side / 2
# Define la secuencia de r. Se selecciona un número moderado para exploración
rseq_bbox2 <- seq(0, rmax_bbox2, length.out = 50) # 50 valores
#O se puede probar con otra escala que propone el
rmax_bi <- maxnndist(pp_bi)
rseq_bi <- seq(0, rmax_bi, length.out = 100)
#
Kcross_bi_inhom <- Kcross.inhom(
X         = pp_bi,
i         = "hotspot",
j         = "coldspot",
lambdaI   = lambda_im_hot,
lambdaJ   = lambda_im_cold,
r         = rseq_bbox,
correction = "border"
)
# Extrae coordenadas de todos los centroides
coords <- sf::st_coordinates(centroides_sf)
# Lambda solo para hotspots
centroides_sf <- centroides_sf |>
mutate(lambda_area_hot = case_when(
log_Qdens_hot95 == 1 ~ log(AREA_HA),
TRUE ~ 0
)) |>
mutate(lambda_area_hot = if_else(lambda_area_hot < 0, 0, lambda_area_hot))
# Crea objeto ppp sobre toda la ventana, usando la marca lambda_area_hot
pp_centroides_hot <- ppp(
x = coords[,1], y = coords[,2],
window = W,
marks = centroides_sf$lambda_area_hot
)
# Calcula la superficie de intensidad lambda usando kernel smoothing
lambda_im_hot <- density.ppp(
pp_centroides_hot,
weights = marks(pp_centroides_hot),
sigma = bw.diggle(pp_centroides_hot)
)
# Corrige negativos residuales y ceros a epsilon mínimo
lambda_im_hot[lambda_im_hot < 1e-10] <- 1e-10
# Igual para coldspots
centroides_sf <- centroides_sf |>
mutate(lambda_area_cold = case_when(
log_Qdens_cold5 == 1 ~ log(AREA_HA),
TRUE ~ 0
)) |>
mutate(lambda_area_cold = if_else(lambda_area_cold < 0, 0, lambda_area_cold))
pp_centroides_cold <- ppp(
x = coords[,1], y = coords[,2],
window = W,
marks = centroides_sf$lambda_area_cold
)
lambda_im_cold <- density.ppp(
pp_centroides_cold,
weights = marks(pp_centroides_cold),
sigma = bw.diggle(pp_centroides_cold)
)
lambda_im_cold[lambda_im_cold < 1e-10] <- 1e-10
#Se visualiza la superficie
plot(lambda_im_cold)
plot(lambda_im_hot)
# 1. Crea una columna de marca en cada set
centroides_hot_sf$grupo  <- "hotspot"
centroides_cold_sf$grupo <- "coldspot"
# 2. Une ambos datasets
centroides_bi_sf <- bind_rows(centroides_hot_sf, centroides_cold_sf)
# 3. Extrae las coordenadas
coords_bi <- sf::st_coordinates(centroides_bi_sf)
# 4. Crea el objeto ppp bivariado
pp_bi <- ppp(
x      = coords_bi[,1],
y      = coords_bi[,2],
window = W,
marks  = as.factor(centroides_bi_sf$grupo)
)
#Se puede explorar una ventana mas grande
rmax_bbox2 <- min_side / 2
# Define la secuencia de r. Se selecciona un número moderado para exploración
rseq_bbox2 <- seq(0, rmax_bbox2, length.out = 50) # 50 valores
#O se puede probar con otra escala que propone el
rmax_bi <- maxnndist(pp_bi)
rseq_bi <- seq(0, rmax_bi, length.out = 100)
#
Kcross_bi_inhom <- Kcross.inhom(
X         = pp_bi,
i         = "hotspot",
j         = "coldspot",
lambdaI   = lambda_im_hot,
lambdaJ   = lambda_im_cold,
r         = rseq_bbox,
correction = "border"
)
plot(Kcross_bi_inhom)
# Convierte el resultado en tibble si no lo has hecho
Kcross_bi_inhom_df <- as_tibble(Kcross_bi_inhom)
# Grafica la función Kcross inhomogénea
p_kcross_inhom <- ggplot(Kcross_bi_inhom_df, aes(x = r)) +
geom_line(aes(y = border, color = "Observada (inhom.)"), size = 1.2) +
geom_line(aes(y = theo, color = "Modelo nulo inhom."), linetype = "dashed", size = 1) +
scale_color_manual(
name = "Curva",
values = c("Observada (inhom.)" = "#E69F00", "Modelo nulo inhom." = "black")
) +
labs(
title = "K cruzada inhomogénea: Hotspots vs Coldspots",
x = "Distancia r (m)",
y = expression(K[inhom](r))
) +
theme_minimal(base_size = 14)
p_kcross_inhom
#guarda el último gráfico generado
ggsave(here("Figures", "kcross_biv_inhomogeneo.png"),
plot = p_kcross_inhom,
width = 8,
height = 8,
dpi = 350)
Kinhom_area_hot <- Kinhom(pp_hot, lambda = lambda_im_hot, r = rseq_bbox)
Kinhom_area_cold <- Kinhom(pp_cold, lambda = lambda_im_cold, r = rseq_bbox)
plot(Kinhom_area_hot)
plot(Kinhom_area_cold)
Kinhom_hot_df <- as_tibble(Kinhom_area_hot)  # o Kinhom_area_cold
Kinhom_cold_df <- as_tibble(Kinhom_area_cold)
p_kinhom_hot <- ggplot(Kinhom_hot_df, aes(x = r)) +
geom_line(aes(y = border, color = "Observada (inhom.)"), size = 1.2) +
geom_line(aes(y = theo, color = "Nulo inhom."), linetype = "dashed", size = 1) +
scale_color_manual(
name = "Curva",
values = c("Observada (inhom.)" = col_hot, "Nulo inhom." = "black")
) +
labs(
title = "Curva Kinhom Hotspots (corregida por área)",
x = "Distancia r",
y = "Kinhom(r)"
) +
#xlim(0, 20000) +
theme_minimal(base_size = 14)
p_kinhom_cold <- ggplot(Kinhom_cold_df, aes(x = r)) +
geom_line(aes(y = border, color = "Observada (inhom.)"), size = 1.2) +
geom_line(aes(y = theo, color = "Nulo inhom."), linetype = "dashed", size = 1) +
scale_color_manual(
name = "Curva",
values = c("Observada (inhom.)" = col_cold, "Nulo inhom." = "black")
) +
labs(
title = "Curva Kinhom Coldspots (corregida por área)",
x = "Distancia r",
y = "Kinhom(r)"
) +
#xlim(0, 20000) +
theme_minimal(base_size = 14)
# Mosaico
p_mosaico_kripley_univ_inhomogeneo <- p_kinhom_hot + p_kinhom_cold + plot_layout(ncol = 1)
p_mosaico_kripley_univ_inhomogeneo
#guarda el último gráfico generado
ggsave(here("Figures", "mosaico_kripley_univ_inhomogeneo.png"),
plot = p_mosaico_kripley_univ_inhomogeneo,
width = 8,
height = 10,
dpi = 350)
# Extrae solo las coordenadas
coords <- sf::st_coordinates(centroides_sf)
# Inversa del área, para cada punto
centroides_sf <- centroides_sf |>
#Crea variable lambda
mutate(lambda_area = log(centroides_sf$AREA_HA)) |>
# Asigna cero en caso de números negativos
mutate(lambda_area = case_when(lambda_area < 0 ~ 0, TRUE ~ lambda_area))
#Se utiliza la misma ventana de observación (polígono + buffer)
pp_centroides <- ppp(
#Coordenadas para la superficie
x = coords[,1], y = coords[,2],
window = W,
#Se define marca para el peso del kernel
marks = centroides_sf$lambda_area
)
# Imágen de intensidad espacial usando kernel smoothing ponderado por la inversa del área
lambda_im <- density.ppp(
pp_centroides,
# Se da el peso según la variable de marca
weights = marks(pp_centroides),
# Ancho de banda
sigma = bw.diggle(pp_centroides)
)
# Se asigna cero a posibles negativos residuales
lambda_im[lambda_im < 0] <- 0
# --- Se hace ahora separando las superficies por hot y cold
# Extrae coordenadas de todos los centroides
coords <- sf::st_coordinates(centroides_sf)
# Lambda solo para hotspots
centroides_sf <- centroides_sf |>
mutate(lambda_area_hot = case_when(
log_Qdens_hot95 == 1 ~ log(AREA_HA),
TRUE ~ 0
)) |>
mutate(lambda_area_hot = if_else(lambda_area_hot < 0, 0, lambda_area_hot))
# Crea objeto ppp sobre toda la ventana, usando la marca lambda_area_hot
pp_centroides_hot <- ppp(
x = coords[,1], y = coords[,2],
window = W,
marks = centroides_sf$lambda_area_hot
)
# Calcula la superficie de intensidad lambda usando kernel smoothing
lambda_im_hot <- density.ppp(
pp_centroides_hot,
weights = marks(pp_centroides_hot),
sigma = bw.diggle(pp_centroides_hot)
)
# Corrige negativos residuales y ceros a epsilon mínimo
lambda_im_hot[lambda_im_hot < 1e-10] <- 1e-10
# Igual para coldspots
centroides_sf <- centroides_sf |>
mutate(lambda_area_cold = case_when(
log_Qdens_cold5 == 1 ~ log(AREA_HA),
TRUE ~ 0
)) |>
mutate(lambda_area_cold = if_else(lambda_area_cold < 0, 0, lambda_area_cold))
pp_centroides_cold <- ppp(
x = coords[,1], y = coords[,2],
window = W,
marks = centroides_sf$lambda_area_cold
)
lambda_im_cold <- density.ppp(
pp_centroides_cold,
weights = marks(pp_centroides_cold),
sigma = bw.diggle(pp_centroides_cold)
)
lambda_im_cold[lambda_im_cold < 1e-10] <- 1e-10
# Visualiza la nueva escala como histograma
hist(centroides_sf$lambda_area, breaks = 100)
hist(centroides_sf$lambda_area_hot, breaks = 100)
hist(centroides_sf$lambda_area_cold, breaks = 100)
#Se visualizan las superficies
plot(lambda_im_cold)
plot(lambda_im_hot)
plot(lambda_im)
View(Kinhom_area_hot)
Kinhom_hot_df <- as_tibble(Kinhom_area_hot)  # o Kinhom_area_cold
Kinhom_cold_df <- as_tibble(Kinhom_area_cold)
p_kinhom_hot <- ggplot(Kinhom_hot_df, aes(x = r)) +
geom_line(aes(y = border.modif, color = "Observada (inhom.)"), size = 1.2) +
geom_line(aes(y = theo, color = "Nulo inhom."), linetype = "dashed", size = 1) +
scale_color_manual(
name = "Curva",
values = c("Observada (inhom.)" = col_hot, "Nulo inhom." = "black")
) +
labs(
title = "Curva Kinhom Hotspots (corregida por área)",
x = "Distancia r",
y = "Kinhom(r)"
) +
#xlim(0, 20000) +
theme_minimal(base_size = 14)
p_kinhom_cold <- ggplot(Kinhom_cold_df, aes(x = r)) +
geom_line(aes(y = border.modif, color = "Observada (inhom.)"), size = 1.2) +
geom_line(aes(y = theo, color = "Nulo inhom."), linetype = "dashed", size = 1) +
scale_color_manual(
name = "Curva",
values = c("Observada (inhom.)" = col_cold, "Nulo inhom." = "black")
) +
labs(
title = "Curva Kinhom Coldspots (corregida por área)",
x = "Distancia r",
y = "Kinhom(r)"
) +
#xlim(0, 20000) +
theme_minimal(base_size = 14)
# Mosaico
p_mosaico_kripley_univ_inhomogeneo <- p_kinhom_hot + p_kinhom_cold + plot_layout(ncol = 1)
p_mosaico_kripley_univ_inhomogeneo
Kinhom_hot_df <- as_tibble(Kinhom_area_hot)  # o Kinhom_area_cold
Kinhom_cold_df <- as_tibble(Kinhom_area_cold)
p_kinhom_hot <- ggplot(Kinhom_hot_df, aes(x = r)) +
geom_line(aes(y = bord.modif, color = "Observada (inhom.)"), size = 1.2) +
geom_line(aes(y = theo, color = "Nulo inhom."), linetype = "dashed", size = 1) +
scale_color_manual(
name = "Curva",
values = c("Observada (inhom.)" = col_hot, "Nulo inhom." = "black")
) +
labs(
title = "Curva Kinhom Hotspots (corregida por área)",
x = "Distancia r",
y = "Kinhom(r)"
) +
#xlim(0, 20000) +
theme_minimal(base_size = 14)
p_kinhom_cold <- ggplot(Kinhom_cold_df, aes(x = r)) +
geom_line(aes(y = bord.modif, color = "Observada (inhom.)"), size = 1.2) +
geom_line(aes(y = theo, color = "Nulo inhom."), linetype = "dashed", size = 1) +
scale_color_manual(
name = "Curva",
values = c("Observada (inhom.)" = col_cold, "Nulo inhom." = "black")
) +
labs(
title = "Curva Kinhom Coldspots (corregida por área)",
x = "Distancia r",
y = "Kinhom(r)"
) +
#xlim(0, 20000) +
theme_minimal(base_size = 14)
# Mosaico
p_mosaico_kripley_univ_inhomogeneo <- p_kinhom_hot + p_kinhom_cold + plot_layout(ncol = 1)
p_mosaico_kripley_univ_inhomogeneo
#guarda el último gráfico generado
ggsave(here("Figures", "mosaico_kripley_univ_inhomogeneo.png"),
plot = p_mosaico_kripley_univ_inhomogeneo,
width = 8,
height = 10,
dpi = 350)
Kinhom_hot_df <- as_tibble(Kinhom_area_hot)  # o Kinhom_area_cold
Kinhom_cold_df <- as_tibble(Kinhom_area_cold)
p_kinhom_hot <- ggplot(Kinhom_hot_df, aes(x = r)) +
geom_line(aes(y = border, color = "Observada (inhom.)"), size = 1.2) +
geom_line(aes(y = theo, color = "Nulo inhom."), linetype = "dashed", size = 1) +
scale_color_manual(
name = "Curva",
values = c("Observada (inhom.)" = col_hot, "Nulo inhom." = "black")
) +
labs(
title = "Curva Kinhom Hotspots (corregida por área)",
x = "Distancia r",
y = "Kinhom(r)"
) +
#xlim(0, 20000) +
theme_minimal(base_size = 14)
p_kinhom_cold <- ggplot(Kinhom_cold_df, aes(x = r)) +
geom_line(aes(y = border, color = "Observada (inhom.)"), size = 1.2) +
geom_line(aes(y = theo, color = "Nulo inhom."), linetype = "dashed", size = 1) +
scale_color_manual(
name = "Curva",
values = c("Observada (inhom.)" = col_cold, "Nulo inhom." = "black")
) +
labs(
title = "Curva Kinhom Coldspots (corregida por área)",
x = "Distancia r",
y = "Kinhom(r)"
) +
#xlim(0, 20000) +
theme_minimal(base_size = 14)
# Mosaico
p_mosaico_kripley_univ_inhomogeneo <- p_kinhom_hot + p_kinhom_cold + plot_layout(ncol = 1)
p_mosaico_kripley_univ_inhomogeneo
#guarda el último gráfico generado
ggsave(here("Figures", "mosaico_kripley_univ_inhomogeneo.png"),
plot = p_mosaico_kripley_univ_inhomogeneo,
width = 8,
height = 10,
dpi = 350)
# Calculo de r máximo de acuerdo a bbox/4
bbox <- st_bbox(limite_buffer)
# Dimensión mínima (en las mismas unidades de tu sistema de coordenadas)
min_side <- min(bbox$xmax - bbox$xmin, bbox$ymax - bbox$ymin)
rmax_bbox <- min_side / 4
# Define la secuencia de r. Se selecciona un número moderado para exploración
rseq_bbox <- seq(0, rmax_bbox, length.out = 100) # 100 valores
# --------------------------------
#Spatstat calcula distancia mínima al borde para todos los puntos
maxr_hot <- maxnndist(pp_hot)
maxr_cold <- maxnndist(pp_cold)
#Si se quiere, también define el r mínimo
minr_hot <- minnndist(pp_hot)
minr_cold <- minnndist(pp_cold)
# Define la secuencia de r. Se selecciona un número moderado para exploración
rseq_hot <- seq(0, maxr_hot, length.out = 50) # 50 valores
rseq_cold <- seq(0, maxr_cold, length.out = 50) # 50 valores
# Calculo de r máximo de acuerdo a bbox/4
bbox <- st_bbox(limite_buffer)
# Dimensión mínima (en las mismas unidades de tu sistema de coordenadas)
min_side <- min(bbox$xmax - bbox$xmin, bbox$ymax - bbox$ymin)
rmax_bbox <- min_side / 4
# Define la secuencia de r. Se selecciona un número moderado para exploración
rseq_bbox <- seq(0, rmax_bbox, length.out = 100) # 100 valores
# --------------------------------
#Spatstat calcula distancia mínima al borde para todos los puntos
maxr_hot <- maxnndist(pp_hot)
maxr_cold <- maxnndist(pp_cold)
#Si se quiere, también define el r mínimo
minr_hot <- minnndist(pp_hot)
minr_cold <- minnndist(pp_cold)
# Define la secuencia de r. Se selecciona un número moderado para exploración
rseq_hot <- seq(0, maxr_hot, length.out = 100) # 50 valores
rseq_cold <- seq(0, maxr_cold, length.out = 100) # 50 valores
Kinhom_area_hot <- Kinhom(pp_hot, lambda = lambda_im_hot, r = rseq_bbox)
Kinhom_area_cold <- Kinhom(pp_cold, lambda = lambda_im_cold, r = rseq_bbox)
plot(Kinhom_area_hot)
plot(Kinhom_area_cold)
Kinhom_hot_df <- as_tibble(Kinhom_area_hot)  # o Kinhom_area_cold
Kinhom_cold_df <- as_tibble(Kinhom_area_cold)
p_kinhom_hot <- ggplot(Kinhom_hot_df, aes(x = r)) +
geom_line(aes(y = border, color = "Observada (inhom.)"), size = 1.2) +
geom_line(aes(y = theo, color = "Nulo inhom."), linetype = "dashed", size = 1) +
scale_color_manual(
name = "Curva",
values = c("Observada (inhom.)" = col_hot, "Nulo inhom." = "black")
) +
labs(
title = "Curva Kinhom Hotspots (corregida por área)",
x = "Distancia r",
y = "Kinhom(r)"
) +
#xlim(0, 20000) +
theme_minimal(base_size = 14)
p_kinhom_cold <- ggplot(Kinhom_cold_df, aes(x = r)) +
geom_line(aes(y = border, color = "Observada (inhom.)"), size = 1.2) +
geom_line(aes(y = theo, color = "Nulo inhom."), linetype = "dashed", size = 1) +
scale_color_manual(
name = "Curva",
values = c("Observada (inhom.)" = col_cold, "Nulo inhom." = "black")
) +
labs(
title = "Curva Kinhom Coldspots (corregida por área)",
x = "Distancia r",
y = "Kinhom(r)"
) +
#xlim(0, 20000) +
theme_minimal(base_size = 14)
# Mosaico
p_mosaico_kripley_univ_inhomogeneo <- p_kinhom_hot + p_kinhom_cold + plot_layout(ncol = 1)
p_mosaico_kripley_univ_inhomogeneo
#guarda el último gráfico generado
ggsave(here("Figures", "mosaico_kripley_univ_inhomogeneo.png"),
plot = p_mosaico_kripley_univ_inhomogeneo,
width = 8,
height = 10,
dpi = 350)
#Se puede explorar una ventana mas grande
rmax_bbox2 <- min_side / 2
# Define la secuencia de r. Se selecciona un número moderado para exploración
rseq_bbox2 <- seq(0, rmax_bbox2, length.out = 50) # 50 valores
#O se puede probar con otra escala que propone el
rmax_bi <- maxnndist(pp_bi)
rseq_bi <- seq(0, rmax_bi, length.out = 100)
#
Kcross_bi_inhom <- Kcross.inhom(
X         = pp_bi,
i         = "hotspot",
j         = "coldspot",
lambdaI   = lambda_im_hot,
lambdaJ   = lambda_im_cold,
r         = rseq_bbox,
correction = "border"
)
plot(Kcross_bi_inhom)
#Se puede explorar una ventana mas grande
rmax_bbox2 <- min_side / 2
# Define la secuencia de r. Se selecciona un número moderado para exploración
rseq_bbox2 <- seq(0, rmax_bbox2, length.out = 100) # 50 valores
#O se puede probar con otra escala que propone el
rmax_bi <- maxnndist(pp_bi)
rseq_bi <- seq(0, rmax_bi, length.out = 100)
#
Kcross_bi_inhom <- Kcross.inhom(
X         = pp_bi,
i         = "hotspot",
j         = "coldspot",
lambdaI   = lambda_im_hot,
lambdaJ   = lambda_im_cold,
r         = rseq_bbox,
correction = "border"
)
plot(Kcross_bi_inhom)
# Convierte el resultado en tibble si no lo has hecho
Kcross_bi_inhom_df <- as_tibble(Kcross_bi_inhom)
# Grafica la función Kcross inhomogénea
p_kcross_inhom <- ggplot(Kcross_bi_inhom_df, aes(x = r)) +
geom_line(aes(y = border, color = "Observada (inhom.)"), size = 1.2) +
geom_line(aes(y = theo, color = "Modelo nulo inhom."), linetype = "dashed", size = 1) +
scale_color_manual(
name = "Curva",
values = c("Observada (inhom.)" = "#E69F00", "Modelo nulo inhom." = "black")
) +
labs(
title = "K cruzada inhomogénea: Hotspots vs Coldspots",
x = "Distancia r (m)",
y = expression(K[inhom](r))
) +
theme_minimal(base_size = 14)
p_kcross_inhom
#guarda el último gráfico generado
ggsave(here("Figures", "kcross_biv_inhomogeneo.png"),
plot = p_kcross_inhom,
width = 8,
height = 8,
dpi = 350)
