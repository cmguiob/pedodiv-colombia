plot = p_coeficientes,
width = 6,
height = 3,
dpi = 350)
# ─────────────────────────────────────────────────────────────────────────────
# 1 · Curvas marginales (efectos predichos) para los 5 predictores del modelo
# ─────────────────────────────────────────────────────────────────────────────
library(sjPlot)     # plot_model()
library(patchwork)  # para combinar
# Helper ─ evita repetir theme & estilo de eje Y
marg_plot <- function(var, xlbl){
plot_model(glm_hot_bal,
type   = "pred",
terms  = sprintf("%s [all]", var),
title  = NULL) +
labs(x = xlbl,
y = "Probabilidad predicha de hotspot") +
theme_minimal(base_size = 12)
}
# ── Generar los cinco gráficos ──────────────────────────────────────────────
p_dem_mean_z            <- marg_plot("dem_mean_z",
"Elevación media (z)")
p_precip_mean_z         <- marg_plot("precip_mean_z",
"Precipitación media (z)")
p_log_slope_cv_dens_z   <- marg_plot("log_slope_cv_dens_z",
"log₁₀ CV pendiente/Área (z)")
p_log_lst_cv_temp_dens_z<- marg_plot("log_lst_cv_temp_dens_z",
"log₁₀ CV LST temporal/Área (z)")
p_precip_cv_temp_dens_z <- marg_plot("precip_cv_temp_dens_z",
"CV precipitación temporal/Área (z)")
# ─────────────────────────────────────────────────────────────────────────────
# 2 · Mosaico 3×2  (la última celda queda vacía para mantener proporción)
# ─────────────────────────────────────────────────────────────────────────────
p_curvas_marginales <-
(p_dem_mean_z | p_precip_mean_z | p_log_slope_cv_dens_z) /
(p_log_lst_cv_temp_dens_z | p_precip_cv_temp_dens_z | plot_spacer())
p_curvas_marginales
# Guardar si se desea
ggsave(
here::here("Figures", "curvas_marginales_modelo_logit_final.png"),
plot   = p_curvas_marginales,
width  = 11, height = 7, dpi = 350
)
# ─────────────────────────────────────────────────────────────────────────────
# 1 · Curvas marginales (efectos predichos) para los 5 predictores del modelo
# ─────────────────────────────────────────────────────────────────────────────
# Helper ─ evita repetir theme & estilo de eje Y
marg_plot <- function(var, xlbl){
plot_model(glm_hot_bal,
type  = "pred",
terms = sprintf("%s [all]", var),
title = NULL) +                     # sin título interno
labs(x = xlbl, y = "P(hotspot)") +
theme_minimal(base_size = 11)
}
# ── Generar los cinco gráficos ──────────────────────────────────────────────
p_dem_mean_z            <- marg_plot("dem_mean_z",
"Elevación media (z)")
p_precip_mean_z         <- marg_plot("precip_mean_z",
"Precipitación media (z)")
p_log_slope_cv_dens_z   <- marg_plot("log_slope_cv_dens_z",
"log₁₀ CV pendiente/Área (z)")
p_log_lst_cv_temp_dens_z<- marg_plot("log_lst_cv_temp_dens_z",
"log₁₀ CV LST temporal/Área (z)")
p_precip_cv_temp_dens_z <- marg_plot("precip_cv_temp_dens_z",
"CV precipitación temporal/Área (z)")
# ─────────────────────────────────────────────────────────────────────────────
# 2 · Mosaico 3×2  (la última celda queda vacía para mantener proporción)
# ─────────────────────────────────────────────────────────────────────────────
p_curvas_marginales <-
(p_dem_mean_z + p_precip_mean_z + p_log_slope_cv_dens_z + p_log_lst_cv_temp_dens_z + p_precip_cv_temp_dens_z)
p_curvas_marginales
# Guardar si se desea
ggsave(
here::here("Figures", "curvas_marginales_modelo_logit_final.png"),
plot   = p_curvas_1fila,
width  = 13, height = 3.2, dpi = 350
)
# ─────────────────────────────────────────────────────────────────────────────
# 1 · Curvas marginales (efectos predichos) para los 5 predictores del modelo
# ─────────────────────────────────────────────────────────────────────────────
# Helper ─ evita repetir theme & estilo de eje Y
marg_plot <- function(var, xlbl){
plot_model(glm_hot_bal,
type  = "pred",
terms = sprintf("%s [all]", var),
title = NULL) +                     # sin título interno
labs(x = xlbl, y = "P(hotspot)") +
theme_minimal(base_size = 11)
}
# ── Generar los cinco gráficos ──────────────────────────────────────────────
p_dem_mean_z            <- marg_plot("dem_mean_z",
"Elevación media (z)")
p_precip_mean_z         <- marg_plot("precip_mean_z",
"Precipitación media (z)")
p_log_slope_cv_dens_z   <- marg_plot("log_slope_cv_dens_z",
"log₁₀ CV pendiente/Área (z)")
p_log_lst_cv_temp_dens_z<- marg_plot("log_lst_cv_temp_dens_z",
"log₁₀ CV LST temporal/Área (z)")
p_precip_cv_temp_dens_z <- marg_plot("precip_cv_temp_dens_z",
"CV precipitación temporal/Área (z)")
# ─────────────────────────────────────────────────────────────────────────────
# 2 · Mosaico 3×2  (la última celda queda vacía para mantener proporción)
# ─────────────────────────────────────────────────────────────────────────────
p_curvas_marginales <- p_dem_mean_z + p_precip_mean_z + p_log_slope_cv_dens_z + p_log_lst_cv_temp_dens_z + p_precip_cv_temp_dens_z + plot_layout(ncol = 5)
p_curvas_marginales
# Guardar si se desea
ggsave(
here::here("Figures", "curvas_marginales_modelo_logit_final.png"),
plot   = p_curvas_1fila,
width  = 13, height = 3.2, dpi = 350
)
# Guardar si se desea
ggsave(
here::here("Figures", "curvas_marginales_modelo_logit_final.png"),
plot   = p_curvas_1fila,
width  = 13, height = 3.2, dpi = 350
)
# Guardar si se desea
ggsave(
here::here("Figures", "p_curvas_marginales.png"),
plot   = p_curvas_1fila,
width  = 13, height = 3.2, dpi = 350
)
# Guardar si se desea
ggsave(
here::here("Figures", "p_curvas_marginales.png"),
plot   = p_curvas_marginales,
width  = 13, height = 3.2, dpi = 350
)
p_curvas_marginales
resid_plot <- function(var, xlbl){
ggplot(modelo_df_balanceado,
aes(x = .data[[var]], y = resid_hot_bal)) +
geom_point(alpha = .25, colour = "#56B4E9", size = 1) +
geom_hline(yintercept = 0, linetype = "dashed") +
labs(x = xlbl, y = "Residuo") +
theme_minimal(base_size = 11)
}
p_residuos_1fila <-
resid_plot("dem_mean_z",              "Elevación media (z)")          +
resid_plot("precip_mean_z",           "Precip. media (z)")            +
resid_plot("log_slope_cv_dens_z",     "log₁₀ CV pend/Área (z)")       +
resid_plot("log_lst_cv_temp_dens_z",  "log₁₀ CV LST temp/Área (z)")   +
resid_plot("precip_cv_temp_dens_z",   "CV precip temp/Área (z)")      +
plot_layout(ncol = 5)
ggsave(
here::here("Figures", "mosaico_residuales_logit.png"),
plot   = p_residuos_1fila,
width  = 13, height = 3.2, dpi = 350
)
View(modelo_df_balanceado)
View(modelo_df_glm)
resid_plot <- function(var, xlbl){
ggplot(modelo_df_glm,
aes(x = .data[[var]], y = resid_hot_bal)) +
geom_point(alpha = .25, colour = "#56B4E9", size = 1) +
geom_hline(yintercept = 0, linetype = "dashed") +
labs(x = xlbl, y = "Residuo") +
theme_minimal(base_size = 11)
}
p_residuos_1fila <-
resid_plot("dem_mean_z",              "Elevación media (z)")          +
resid_plot("precip_mean_z",           "Precip. media (z)")            +
resid_plot("log_slope_cv_dens_z",     "log₁₀ CV pend/Área (z)")       +
resid_plot("log_lst_cv_temp_dens_z",  "log₁₀ CV LST temp/Área (z)")   +
resid_plot("precip_cv_temp_dens_z",   "CV precip temp/Área (z)")      +
plot_layout(ncol = 5)
ggsave(
here::here("Figures", "mosaico_residuales_logit.png"),
plot   = p_residuos_1fila,
width  = 13, height = 3.2, dpi = 350
)
# Extrae los hotspots observados como puntos
hotspots_obs_sf <- modelo_df_glm |>
filter(log_Qdens_hot95 == 1)
# Mapa 1: solo hotspots observados como puntos, UCS en fondo
p_mapa_obs <- ggplot() +
geom_sf(data = modelo_df_glm, fill = NA, color = "grey90", size = 0.1) +
geom_sf(data = hotspots_obs_sf, color = col_hot, size = 2) +
labs(title = "Hotspots observados (puntos)") +
theme_minimal()
p_residuos_1fila
pal_zissou <- paletteer_c("grDevices::Zissou 1", 100)
col_hot  <- pal_zissou[90]
# Extrae los hotspots observados como puntos
hotspots_obs_sf <- modelo_df_glm |>
filter(log_Qdens_hot95 == 1)
# Mapa 1: solo hotspots observados como puntos, UCS en fondo
p_mapa_obs <- ggplot() +
geom_sf(data = modelo_df_glm, fill = NA, color = "grey90", size = 0.1) +
geom_sf(data = hotspots_obs_sf, color = col_hot, size = 2) +
labs(title = "Hotspots observados (puntos)") +
theme_minimal()
# Mapa 2: probabilidad predicha
p_mapa_pred <- ggplot(modelo_df_glm) +
geom_sf(aes(fill = prob_hot_bal), color = NA) +
scale_fill_gradientn(
colours = rev(viridis::plasma(100)),  # ← rev() invierte los colores
limits = c(0, 0.6),
oob = scales::squish,
name = "Probabilidad\npredicha"
) +
labs(title = "Probabilidad predicha de hotspot") +
theme_minimal()
# Mapa 3: residuales
p_mapa_resid <- ggplot(modelo_df_glm) +
geom_sf(aes(fill = resid_hot_bal), color = NA) +
scale_fill_gradientn(
colours = viridis::viridis(100),
limits = c(-0.5, 0.5),
name = "Residuo"
) +
labs(title = "Residuales del modelo") +
theme_minimal()
# Mosaico con patchwork
p_mapas_logit <- p_mapa_obs + p_mapa_pred + p_mapa_resid + plot_layout(ncol = 3)
# Guardar la figura
ggsave(
filename = here("Figures", "mosaico_mapa_prediccion_logit.png"),
plot = p_mapas_logit,
width = 12,
height = 5.5,
dpi = 350
)
# Mapa 2: probabilidad predicha
p_mapa_pred <- ggplot(modelo_df_glm) +
geom_sf(aes(fill = prob_hot_bal), color = NA) +
scale_fill_gradientn(
colours = rev(viridis::plasma(100)),  # ← rev() invierte los colores
limits = c(0, 0.3),
oob = scales::squish,
name = "Probabilidad\npredicha"
) +
labs(title = "Probabilidad predicha de hotspot") +
theme_minimal()
# Mosaico con patchwork
p_mapas_logit <- p_mapa_obs + p_mapa_pred + p_mapa_resid + plot_layout(ncol = 3)
# Guardar la figura
ggsave(
filename = here("Figures", "mosaico_mapa_prediccion_logit.png"),
plot = p_mapas_logit,
width = 12,
height = 5.5,
dpi = 350
)
# Usamos los centroides de los UCS para definir relaciones espaciales
modelo_centroides <- modelo_df_glm |>
st_centroid(of_largest_polygon = TRUE)
# Extraemos coordenadas de los centroides
coords <- st_coordinates(modelo_centroides)
# Construye vecinos por k más cercanos (k=6 es común en análisis ecológicos y espaciales)
k_vecinos <- knearneigh(coords, k = 6)
vecindario <- knn2nb(k_vecinos)
# Matriz de pesos espacial estandarizada (filas suman 1)
pesos <- nb2listw(vecindario, style = "W", zero.policy = TRUE)
# Moran I global sobre residuales del modelo logit
moran_global <- moran.test(modelo_df_glm$resid_hot_bal, listw = pesos, zero.policy = TRUE)
print(moran_global)
# Moran local (LISA)
moran_local <- localmoran(modelo_df_glm$resid_hot_bal, listw = pesos, zero.policy = TRUE)
# Calcula el lag espacial de los residuos (para el scatterplot)
modelo_df_balanceado <- modelo_df_glm |>
mutate(
local_moran_I = moran_local[, 1],
p_valor_local = moran_local[, 5],
lag_resid = lag.listw(pesos, resid_hot_bal)
)
# Clasifica tipo de agrupamiento espacial
modelo_df_balanceado <- modelo_df_glm |>
mutate(
cluster_tipo = case_when(
resid_hot_bal > 0 & lag_resid > 0 ~ "High-High",
resid_hot_bal < 0 & lag_resid < 0 ~ "Low-Low",
resid_hot_bal > 0 & lag_resid < 0 ~ "High-Low",
resid_hot_bal < 0 & lag_resid > 0 ~ "Low-High",
TRUE ~ "No significativo"
),
cluster_tipo = ifelse(p_valor_local > 0.05, "No significativo", cluster_tipo)
)
# Moran local (LISA)
moran_local <- localmoran(modelo_df_glm$resid_hot_bal, listw = pesos, zero.policy = TRUE)
# Calcula el lag espacial de los residuos (para el scatterplot)
modelo_df_balanceado <- modelo_df_glm |>
mutate(
local_moran_I = moran_local[, 1],
p_valor_local = moran_local[, 5],
lag_resid = lag.listw(pesos, resid_hot_bal)
)
# Clasifica tipo de agrupamiento espacial
modelo_df_glm <- modelo_df_glm |>
mutate(
cluster_tipo = case_when(
resid_hot_bal > 0 & lag_resid > 0 ~ "High-High",
resid_hot_bal < 0 & lag_resid < 0 ~ "Low-Low",
resid_hot_bal > 0 & lag_resid < 0 ~ "High-Low",
resid_hot_bal < 0 & lag_resid > 0 ~ "Low-High",
TRUE ~ "No significativo"
),
cluster_tipo = ifelse(p_valor_local > 0.05, "No significativo", cluster_tipo)
)
# Moran local (LISA)
moran_local <- localmoran(modelo_df_glm$resid_hot_bal, listw = pesos, zero.policy = TRUE)
# Calcula el lag espacial de los residuos (para el scatterplot)
modelo_df_glm <- modelo_df_glm |>
mutate(
local_moran_I = moran_local[, 1],
p_valor_local = moran_local[, 5],
lag_resid = lag.listw(pesos, resid_hot_bal)
)
# Clasifica tipo de agrupamiento espacial
modelo_df_glm <- modelo_df_glm |>
mutate(
cluster_tipo = case_when(
resid_hot_bal > 0 & lag_resid > 0 ~ "High-High",
resid_hot_bal < 0 & lag_resid < 0 ~ "Low-Low",
resid_hot_bal > 0 & lag_resid < 0 ~ "High-Low",
resid_hot_bal < 0 & lag_resid > 0 ~ "Low-High",
TRUE ~ "No significativo"
),
cluster_tipo = ifelse(p_valor_local > 0.05, "No significativo", cluster_tipo)
)
# Moran local (LISA)
moran_local <- localmoran(modelo_df_glm$resid_hot_bal, listw = pesos, zero.policy = TRUE)
# Calcula el lag espacial de los residuos (para el scatterplot)
modelo_df_glm <- modelo_df_glm |>
mutate(
local_moran_I = moran_local[, 1],
p_valor_local = moran_local[, 5],
lag_resid = lag.listw(pesos, resid_hot_bal)
)
# Clasifica tipo de agrupamiento espacial
modelo_df_glm <- modelo_df_glm |>
mutate(
cluster_tipo = case_when(
resid_hot_bal > 0 & lag_resid > 0 ~ "High-High",
resid_hot_bal < 0 & lag_resid < 0 ~ "Low-Low",
resid_hot_bal > 0 & lag_resid < 0 ~ "High-Low",
resid_hot_bal < 0 & lag_resid > 0 ~ "Low-High",
TRUE ~ "No significativo"
),
cluster_tipo = ifelse(p_valor_local > 0.05, "No significativo", cluster_tipo)
)
# Define colores personalizados desde paleta Zissou1 (viridis-like)
pal <- wes_palette("Zissou1", 100, type = "continuous")
colores_lisa <- c(
"High-High"        = pal[90],   # rojo intenso
"Low-Low"          = pal[10],   # azul oscuro
"High-Low"         = pal[70],   # naranja
"Low-High"         = pal[30],   # celeste
"No significativo" = "grey90"   # gris neutro
)
# Gráfico 1: Scatterplot de Moran local coloreado por tipo de agrupamiento
p_scatter_lisa <- ggplot(modelo_df_balanceado, aes(x = resid_hot_bal, y = lag_resid)) +
geom_point(aes(color = cluster_tipo), alpha = 0.8, size = 1.5) +
geom_smooth(method = "lm", se = FALSE, color = "black", linewidth = 0.5) +
geom_hline(yintercept = 0, linetype = "dashed", color = "grey60") +
geom_vline(xintercept = 0, linetype = "dashed", color = "grey60") +
scale_color_manual(values = colores_lisa) +
labs(
title = "Diagrama de dispersión Moran local",
x = "Residuo del modelo",
y = "Lag espacial",
color = "Tipo de agrupamiento"
) +
theme_minimal()
# Gráfico 2: Mapa LISA de agrupamientos espaciales
p_moran_lisa <- ggplot(modelo_df_balanceado) +
geom_sf(aes(fill = cluster_tipo), color = NA) +
scale_fill_manual(values = colores_lisa, na.value = "white") +
labs(title = "Mapa: agrupamientos LISA (residuales)",
fill = "Tipo de agrupamiento") +
theme_minimal()
# Gráfico 3: Mapa de valores Ii (magnitude de autocorrelación local)
p_ii_mapa <- ggplot(modelo_df_balanceado) +
geom_sf(aes(fill = local_moran_I), color = NA) +
scale_fill_viridis_c(name = "Ii", option = "magma", direction = -1) +
labs(title = "Mapa: valor del estadístico local (Ii)") +
theme_minimal()
# Composición de los tres gráficos
p_lisa_tripanel <- p_scatter_lisa + p_moran_lisa + p_ii_mapa +
plot_layout(ncol = 3)
# Mostrar y guardar
print(p_lisa_tripanel)
# Define colores personalizados desde paleta Zissou1 (viridis-like)
pal <- wes_palette("Zissou1", 100, type = "continuous")
colores_lisa <- c(
"High-High"        = pal[90],   # rojo intenso
"Low-Low"          = pal[10],   # azul oscuro
"High-Low"         = pal[70],   # naranja
"Low-High"         = pal[30],   # celeste
"No significativo" = "grey90"   # gris neutro
)
# Gráfico 1: Scatterplot de Moran local coloreado por tipo de agrupamiento
p_scatter_lisa <- ggplot(modelo_df_glm, aes(x = resid_hot_bal, y = lag_resid)) +
geom_point(aes(color = cluster_tipo), alpha = 0.8, size = 1.5) +
geom_smooth(method = "lm", se = FALSE, color = "black", linewidth = 0.5) +
geom_hline(yintercept = 0, linetype = "dashed", color = "grey60") +
geom_vline(xintercept = 0, linetype = "dashed", color = "grey60") +
scale_color_manual(values = colores_lisa) +
labs(
title = "Diagrama de dispersión Moran local",
x = "Residuo del modelo",
y = "Lag espacial",
color = "Tipo de agrupamiento"
) +
theme_minimal()
# Gráfico 2: Mapa LISA de agrupamientos espaciales
p_moran_lisa <- ggplot(modelo_df_glm) +
geom_sf(aes(fill = cluster_tipo), color = NA) +
scale_fill_manual(values = colores_lisa, na.value = "white") +
labs(title = "Mapa: agrupamientos LISA (residuales)",
fill = "Tipo de agrupamiento") +
theme_minimal()
# Gráfico 3: Mapa de valores Ii (magnitude de autocorrelación local)
p_ii_mapa <- ggplot(modelo_df_glm) +
geom_sf(aes(fill = local_moran_I), color = NA) +
scale_fill_viridis_c(name = "Ii", option = "magma", direction = -1) +
labs(title = "Mapa: valor del estadístico local (Ii)") +
theme_minimal()
# Composición de los tres gráficos
p_lisa_tripanel <- p_scatter_lisa + p_moran_lisa + p_ii_mapa +
plot_layout(ncol = 3)
# Mostrar y guardar
print(p_lisa_tripanel)
ggsave(
here::here("Figures", "moran_local_composicion_logit.png"),
plot = p_lisa_tripanel,
width = 15,
height = 5,
dpi = 300
)
# Mapa 2: probabilidad predicha
q99 <- quantile(modelo_df_glm$prob_hot_bal, .99, na.rm = TRUE)
p_mapa_pred <- ggplot(modelo_df_glm) +
geom_sf(aes(fill = prob_hot_bal), colour = NA) +
scale_fill_gradientn(
colours = rev(viridis::plasma(100)),
limits  = c(0, q99),           # recorte al 99 %
oob     = scales::squish,
name    = "Probabilidad\npredicha"
) +
theme_minimal() +
labs(title = "Probabilidad predicha (0 – P₉₉)")
# Mosaico con patchwork
p_mapas_logit <- p_mapa_obs + p_mapa_pred + p_mapa_resid + plot_layout(ncol = 3)
# Guardar la figura
ggsave(
filename = here("Figures", "mosaico_mapa_prediccion_logit.png"),
plot = p_mapas_logit,
width = 12,
height = 5.5,
dpi = 350
)
pacman::p_load(
here,         # manejo de rutas relativas al proyecto
remotes,      # instalar paquetes desde GitHub
sf,           # manejo de objetos espaciales vectoriales
dplyr,        # manipulación de data frames (verbos como filter, mutate, join)
tidyr,        # transformación de datos (pivot_longer, pivot_wider, etc.)
readr,        # lectura rápida de archivos CSV
performance,  # métricas de modelos (R2 de Tjur, VIF, etc.)
ggdist,       # distribución visual de predicciones (stat_halfeye, intervalos)
scales,       # transformación de escalas (log10, percentiles, breaks)
ggplot2,      # sistema de gráficos base
grid,
GGally,       # mapa de correlación
sjPlot,       # visualización de modelos y efectos marginales
spdep,        # Análisis de dependencia espacial
scales,       # Transformación de escalas
classInt,     # cortes con cuantiles
paletteer,    # acceso a múltiples paletas de colores (ej. viridis, wesanderson)
googledrive,  # autenticación y manipulación de archivos en Google Drive
patchwork,    # combinación de gráficos ggplot (p1 + p2)
qs            # guardado y carga rápida de objetos R
)
# Mapa 2: probabilidad predicha
# Genera 5 cortes (quintiles) sobre la columna de probabilidad
cortes <- classInt::classIntervals(modelo_df_glm$prob_hot_bal,
n = 5, style = "quantile")$brks
# Mapa con los 5 colores
ggplot(modelo_df_glm) +
geom_sf(aes(fill = cut(prob_hot_bal, cortes,
include.lowest = TRUE, dig.lab = 3)),
colour = NA) +
scale_fill_manual(
values = rev(viridis::plasma(5)),
name   = "Cuantiles de p"
) +
labs(title = "Probabilidad predicha de hotspot (quintiles)") +
theme_minimal()
# Mapa con los 5 colores
p_mapa_pred <- ggplot(modelo_df_glm) +
geom_sf(aes(fill = cut(prob_hot_bal, cortes,
include.lowest = TRUE, dig.lab = 3)),
colour = NA) +
scale_fill_manual(
values = rev(viridis::plasma(5)),
name   = "Cuantiles de p"
) +
labs(title = "Probabilidad predicha de hotspot (quintiles)") +
theme_minimal()
# Mosaico con patchwork
p_mapas_logit <- p_mapa_obs + p_mapa_pred + p_mapa_resid + plot_layout(ncol = 3)
# Guardar la figura
ggsave(
filename = here("Figures", "mosaico_mapa_prediccion_logit.png"),
plot = p_mapas_logit,
width = 12,
height = 5.5,
dpi = 350
)
