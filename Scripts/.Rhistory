"Low-Low"         = pal[10],   # azul oscuro
"High-Low"        = pal[70],   # naranja intermedio
"Low-High"        = pal[30],   # celeste
"No significativo"= "grey80"   # neutro
)
# Mapa del Moran Local
p_moran_lisa <- ggplot(modelo_df_balanceado) +
geom_sf(aes(fill = cluster_tipo), color = NA) +
scale_fill_manual(values = colores_lisa, na.value = "white") +
labs(title = "Moran I local (LISA) sobre residuales",
fill = "Tipo de agrupamiento") +
theme_minimal()
print(p_moran_lisa)
# Guardar figura
ggsave(
here::here("Figures", "moran_local_residuos_logit.png"),
plot = p_moran_lisa,
width = 8,
height = 6,
dpi = 300
)
# Colores específicos seleccionados de la paleta
colores_lisa <- c(
"High-High"       = pal[90],   # rojo intenso
"Low-Low"         = pal[10],   # azul oscuro
"High-Low"        = pal[70],   # naranja intermedio
"Low-High"        = pal[30],   # celeste
"No significativo"= "grey92"   # neutro
)
# Mapa del Moran Local
p_moran_lisa <- ggplot(modelo_df_balanceado) +
geom_sf(aes(fill = cluster_tipo), color = NA) +
scale_fill_manual(values = colores_lisa, na.value = "white") +
labs(title = "Moran I local (LISA) sobre residuales",
fill = "Tipo de agrupamiento") +
theme_minimal()
print(p_moran_lisa)
# Guardar figura
ggsave(
here::here("Figures", "moran_local_residuos_logit.png"),
plot = p_moran_lisa,
width = 8,
height = 6,
dpi = 300
)
# Usamos los centroides de los UCS para definir relaciones espaciales
modelo_centroides <- modelo_df_balanceado |>
st_centroid(of_largest_polygon = TRUE)
# Extraemos coordenadas de los centroides
coords <- st_coordinates(modelo_centroides)
# Construye vecinos por k más cercanos (k=6 es común en análisis ecológicos y espaciales)
k_vecinos <- knearneigh(coords, k = 6)
vecindario <- knn2nb(k_vecinos)
# Matriz de pesos espacial estandarizada (filas suman 1)
pesos <- nb2listw(vecindario, style = "W", zero.policy = TRUE)
# Moran I global sobre residuales del modelo logit
moran_global <- moran.test(modelo_df_balanceado$resid_hot_bal, listw = pesos, zero.policy = TRUE)
print(moran_global)
# Moran local (LISA)
moran_local <- localmoran(modelo_df_balanceado$resid_hot_bal, listw = pesos, zero.policy = TRUE)
# Calcula el lag espacial de los residuos (para el scatterplot)
modelo_df_balanceado <- modelo_df_balanceado |>
mutate(
local_moran_I = moran_local[, 1],
p_valor_local = moran_local[, 5],
lag_resid = lag.listw(pesos, resid_hot_bal)
)
# Clasifica tipo de agrupamiento espacial
modelo_df_balanceado <- modelo_df_balanceado |>
mutate(
cluster_tipo = case_when(
resid_hot_bal > 0 & lag_resid > 0 ~ "High-High",
resid_hot_bal < 0 & lag_resid < 0 ~ "Low-Low",
resid_hot_bal > 0 & lag_resid < 0 ~ "High-Low",
resid_hot_bal < 0 & lag_resid > 0 ~ "Low-High",
TRUE ~ "No significativo"
),
cluster_tipo = ifelse(p_valor_local > 0.05, "No significativo", cluster_tipo)
)
# Define colores personalizados desde paleta Zissou1 (viridis-like)
pal <- wes_palette("Zissou1", 100, type = "continuous")
colores_lisa <- c(
"High-High"        = pal[90],   # rojo intenso
"Low-Low"          = pal[10],   # azul oscuro
"High-Low"         = pal[70],   # naranja
"Low-High"         = pal[30],   # celeste
"No significativo" = "grey90"   # gris neutro
)
# Gráfico 1: Scatterplot de Moran local (residuo vs. lag)
p_scatter_lisa <- ggplot(modelo_df_balanceado, aes(x = resid_hot_bal, y = lag_resid)) +
geom_point(alpha = 0.6, color = "grey40") +
geom_smooth(method = "lm", se = FALSE, color = "black", linewidth = 0.6) +
geom_hline(yintercept = 0, linetype = "dashed", color = "grey60") +
geom_vline(xintercept = 0, linetype = "dashed", color = "grey60") +
labs(
title = "Diagrama de dispersión Moran local",
x = "Residuo del modelo",
y = "Lag espacial"
) +
theme_minimal()
# Gráfico 2: Mapa LISA de agrupamientos espaciales
p_moran_lisa <- ggplot(modelo_df_balanceado) +
geom_sf(aes(fill = cluster_tipo), color = NA) +
scale_fill_manual(values = colores_lisa, na.value = "white") +
labs(title = "Mapa: agrupamientos LISA (residuales)",
fill = "Tipo de agrupamiento") +
theme_minimal()
# Gráfico 3: Mapa de valores Ii (magnitude de autocorrelación local)
p_ii_mapa <- ggplot(modelo_df_balanceado) +
geom_sf(aes(fill = local_moran_I), color = NA) +
scale_fill_viridis_c(name = "Ii", option = "magma", direction = -1) +
labs(title = "Mapa: valor del estadístico local (Ii)") +
theme_minimal()
# Composición de los tres gráficos
p_lisa_tripanel <- p_scatter_lisa + p_moran_lisa + p_ii_mapa +
plot_layout(ncol = 3)
# Mostrar y guardar
print(p_lisa_tripanel)
ggsave(
here::here("Figures", "moran_local_composicion_logit.png"),
plot = p_lisa_tripanel,
width = 15,
height = 5,
dpi = 300
)
# Define colores personalizados desde paleta Zissou1 (viridis-like)
pal <- wes_palette("Zissou1", 100, type = "continuous")
colores_lisa <- c(
"High-High"        = pal[90],   # rojo intenso
"Low-Low"          = pal[10],   # azul oscuro
"High-Low"         = pal[70],   # naranja
"Low-High"         = pal[30],   # celeste
"No significativo" = "grey90"   # gris neutro
)
# Gráfico 1: Scatterplot de Moran local coloreado por tipo de agrupamiento
p_scatter_lisa <- ggplot(modelo_df_balanceado, aes(x = resid_hot_bal, y = lag_resid)) +
geom_point(aes(color = cluster_tipo), alpha = 0.8, size = 1.5) +
geom_smooth(method = "lm", se = FALSE, color = "black", linewidth = 0.5) +
geom_hline(yintercept = 0, linetype = "dashed", color = "grey60") +
geom_vline(xintercept = 0, linetype = "dashed", color = "grey60") +
scale_color_manual(values = colores_lisa) +
labs(
title = "Diagrama de dispersión Moran local",
x = "Residuo del modelo",
y = "Lag espacial",
color = "Tipo de agrupamiento"
) +
theme_minimal()
# Gráfico 2: Mapa LISA de agrupamientos espaciales
p_moran_lisa <- ggplot(modelo_df_balanceado) +
geom_sf(aes(fill = cluster_tipo), color = NA) +
scale_fill_manual(values = colores_lisa, na.value = "white") +
labs(title = "Mapa: agrupamientos LISA (residuales)",
fill = "Tipo de agrupamiento") +
theme_minimal()
# Gráfico 3: Mapa de valores Ii (magnitude de autocorrelación local)
p_ii_mapa <- ggplot(modelo_df_balanceado) +
geom_sf(aes(fill = local_moran_I), color = NA) +
scale_fill_viridis_c(name = "Ii", option = "magma", direction = -1) +
labs(title = "Mapa: valor del estadístico local (Ii)") +
theme_minimal()
# Composición de los tres gráficos
p_lisa_tripanel <- p_scatter_lisa + p_moran_lisa + p_ii_mapa +
plot_layout(ncol = 3)
# Mostrar y guardar
print(p_lisa_tripanel)
ggsave(
here::here("Figures", "moran_local_composicion_logit.png"),
plot = p_lisa_tripanel,
width = 15,
height = 5,
dpi = 300
)
# Extrae los hotspots observados como puntos
hotspots_obs_sf <- modelo_df_balanceado |>
filter(log_Qdens_hot95 == 1)
# Mapa 1: solo hotspots observados como puntos, UCS en fondo
p_mapa_obs <- ggplot() +
geom_sf(data = modelo_df_balanceado, fill = NA, color = "grey90", size = 0.1) +
geom_sf(data = hotspots_obs_sf, color = col_hot, size = 2) +
labs(title = "Hotspots observados (puntos)") +
theme_minimal()
# Mapa 2: probabilidad predicha
p_mapa_pred <- ggplot(modelo_df_balanceado) +
geom_sf(aes(fill = prob_hot_bal), color = NA) +
scale_fill_gradientn(
colours = rev(viridis::plasma(100)),  # ← rev() invierte los colores
limits = c(0, 0.6),
oob = scales::squish,
name = "Probabilidad\npredicha"
) +
labs(title = "Probabilidad predicha de hotspot") +
theme_minimal()
# Mapa 3: residuales
p_mapa_resid <- ggplot(modelo_df_balanceado) +
geom_sf(aes(fill = resid_hot_bal), color = NA) +
scale_fill_gradientn(
colours = viridis::viridis(100),
limits = c(-0.5, 0.5),
name = "Residuo"
) +
labs(title = "Residuales del modelo") +
theme_minimal()
# Mosaico con patchwork
p_mapas_logit <- p_mapa_obs + p_mapa_pred + p_mapa_resid + plot_layout(ncol = 3)
# Guardar la figura
ggsave(
filename = here("Figures", "mosaico_mapa_prediccion_logit.png"),
plot = p_mapas_logit,
width = 12,
height = 5.5,
dpi = 350
)
# Paleta personalizada
color_punto <- "#56B4E9"
color_etiqueta <- "#FFD700"
# Gráfico de coeficientes estimados
p_coeficientes <- plot_model(
glm_hot_bal,
type = "est",
vline.color = "#FFD700",
show.values = TRUE,
transform = NULL,
value.offset = .3,
value.size = 4
) +
labs(title = "Coeficientes estimados del modelo B") +
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14),
legend.position = "none"
) +
scale_color_manual(values = rep(color_punto, 6)) +
scale_fill_manual(values = rep(color_punto, 6)) +
geom_text(color = color_etiqueta, size = 4, fontface = "bold")
# Guarda la figura
ggsave(here("Figures", "coeficientes_logit_b.png"),
plot = p_coeficientes,
width = 6,
height = 5,
dpi = 350)
p_coeficientes <- plot_model(glm_hot_bal,
type = "est",
vline.color = "red",
show.values = TRUE,
transform = NULL,
value.offset = .3) +
labs(title = "Coeficientes estimados del modelo B")
p_coeficientes
# Guarda la figura
ggsave(here("Figures", "coeficientes_logit_b.png"),
plot = p_coeficientes,
width = 6,
height = 5,
dpi = 350)
p_coeficientes <- plot_model(glm_hot_bal,
type = "est",
vline.color = "red",
show.values = TRUE,
transform = NULL,
value.offset = .3) +
labs(title = "Coeficientes estimados del modelo B")
p_coeficientes
# Guarda la figura
ggsave(here("Figures", "coeficientes_logit_b.png"),
plot = p_coeficientes,
width = 8,
height = 3,
dpi = 350)
p_coeficientes <- plot_model(glm_hot_bal,
type = "est",
vline.color = "red",
show.values = TRUE,
transform = NULL,
value.offset = .3) +
labs(title = "Coeficientes estimados del modelo B")
p_coeficientes
# Guarda la figura
ggsave(here("Figures", "coeficientes_logit_b.png"),
plot = p_coeficientes,
width = 6,
height = 3,
dpi = 350)
# log_dem_cv_dens_z: log(CV de elevación densificado por área), estandarizado
p_margin_log_dem_cv_dens_z <- plot_model(glm_hot_bal, type = "pred", terms = "log_dem_cv_dens_z [all]", title = NULL) +
labs(x = "log(CV de elevación, densificado y estándar)",
y = "Probabilidad predicha de hotspot") +
theme_minimal()
# log_slope_cv_dens_z: log(CV de pendiente densificado por área), estandarizado
p_margin_log_slope_cv_dens_z <- plot_model(glm_hot_bal, type = "pred", terms = "log_slope_cv_dens_z [all]", title = NULL) +
labs(x = "log(CV de pendiente, densificado y estándar)",
y = "Probabilidad predicha de hotspot") +
theme_minimal()
# log_lst_cv_temp_dens_z: log(CV de temperatura superficial densificado por área), estandarizado
p_margin_log_lst_cv_dens_z <- plot_model(glm_hot_bal, type = "pred", terms = "log_lst_cv_temp_dens_z [all]", title = NULL) +
labs(x = "log(CV temporal de temperatura superficial, densificado y estándar)",
y = "Probabilidad predicha de hotspot") +
theme_minimal()
# Mosaico de curvas marginales
p_curvas_marginales_logit_b <- p_margin_log_dem_cv_dens_z + p_margin_log_slope_cv_dens_z + p_margin_log_lst_cv_dens_z
# Visualiza las curvas
p_curvas_marginales_logit_b
# Guarda la figura
ggsave(here("Figures", "curvas_marginales_modelo_logit_b.png"),
plot = p_curvas_marginales_logit_b,
width = 9,
height = 4,
dpi = 350)
# log_dem_cv_dens_z: log(CV de elevación densificado por área), estandarizado
p_margin_log_dem_cv_dens_z <- plot_model(glm_hot_bal, type = "pred", terms = "log_dem_cv_dens_z [all]", title = NULL) +
labs(x = "log(CV de DEM, densificado y estándar)",
y = "Probabilidad predicha de hotspot") +
theme_minimal()
# log_slope_cv_dens_z: log(CV de pendiente densificado por área), estandarizado
p_margin_log_slope_cv_dens_z <- plot_model(glm_hot_bal, type = "pred", terms = "log_slope_cv_dens_z [all]", title = NULL) +
labs(x = "log(CV de SLOPE, densificado y estándar)",
y = "Probabilidad predicha de hotspot") +
theme_minimal()
# log_lst_cv_temp_dens_z: log(CV de temperatura superficial densificado por área), estandarizado
p_margin_log_lst_cv_dens_z <- plot_model(glm_hot_bal, type = "pred", terms = "log_lst_cv_temp_dens_z [all]", title = NULL) +
labs(x = "log(CV temporal de LST, densificado y estándar)",
y = "Probabilidad predicha de hotspot") +
theme_minimal()
# Mosaico de curvas marginales
p_curvas_marginales_logit_b <- p_margin_log_dem_cv_dens_z + p_margin_log_slope_cv_dens_z + p_margin_log_lst_cv_dens_z
# Visualiza las curvas
p_curvas_marginales_logit_b
# Guarda la figura
ggsave(here("Figures", "curvas_marginales_modelo_logit_b.png"),
plot = p_curvas_marginales_logit_b,
width = 9,
height = 4,
dpi = 350)
# === Modelo B: Hotspots vs muestra aleatoria (balanceado) ===
glm_hot_bal <- glm(
formula = log_Qdens_hot95 ~ dem_mean_z + slope_mean_z + log_dem_cv_dens_z +
log_slope_cv_dens_z + log_lst_cv_temp_dens_z,
data = modelo_df_balanceado,
family = binomial()
)
# Agrega predicción y residuales a modelo_df_balanceado
modelo_df_balanceado <- modelo_df_balanceado |>
mutate(
prob_hot_bal = predict(glm_hot_bal, type = "response"),
resid_hot_bal = residuals(glm_hot_bal, type = "response")
)
# Reporta ajuste
summary(glm_hot_bal)
performance::r2_tjur(glm_hot_bal)
p_coeficientes <- plot_model(glm_hot_bal,
type = "est",
vline.color = "red",
show.values = TRUE,
transform = NULL,
value.offset = .3) +
labs(title = "Coeficientes estimados del modelo")
p_coeficientes
# Guarda la figura
ggsave(here("Figures", "coeficientes_logit_b.png"),
plot = p_coeficientes,
width = 6,
height = 3,
dpi = 350)
p_coeficientes <- plot_model(glm_hot_bal,
type = "est",
vline.color = "red",
show.values = TRUE,
transform = NULL,
value.offset = .3) +
labs(title = "Coeficientes estimados del modelo") +
theme_sjplot2()
p_coeficientes
# Guarda la figura
ggsave(here("Figures", "coeficientes_logit_b.png"),
plot = p_coeficientes,
width = 6,
height = 3,
dpi = 350)
p_coeficientes <- plot_model(glm_hot_bal,
type = "est",
vline.color = "red",
show.values = TRUE,
transform = NULL,
value.offset = .3) +
labs(title = "Coeficientes estimados del modelo") +
theme_sjplot2() +
+ scale_color_sjplot("simply")
p_coeficientes <- plot_model(glm_hot_bal,
type = "est",
vline.color = "red",
show.values = TRUE,
transform = NULL,
value.offset = .3) +
labs(title = "Coeficientes estimados del modelo") +
theme_sjplot2() +
scale_color_sjplot("simply")
p_coeficientes
# Guarda la figura
ggsave(here("Figures", "coeficientes_logit_b.png"),
plot = p_coeficientes,
width = 6,
height = 3,
dpi = 350)
sjPlot::show_sjplot_pals()
p_coeficientes <- plot_model(glm_hot_bal,
type = "est",
vline.color = "red",
show.values = TRUE,
transform = NULL,
value.offset = .3) +
labs(title = "Coeficientes estimados del modelo") +
theme_sjplot2() +
scale_color_sjplot("metro")
p_coeficientes
# Guarda la figura
ggsave(here("Figures", "coeficientes_logit_b.png"),
plot = p_coeficientes,
width = 6,
height = 3,
dpi = 350)
sjPlot::show_sjplot_pals()
p_coeficientes <- plot_model(glm_hot_bal,
type = "est",
vline.color = "red",
show.values = TRUE,
transform = NULL,
value.offset = .3) +
labs(title = "Coeficientes estimados del modelo") +
theme_sjplot2() +
scale_color_sjplot("hero")
# === Modelo B: Hotspots vs muestra aleatoria (balanceado) ===
glm_hot_bal <- glm(
formula = log_Qdens_hot95 ~ dem_mean_z + slope_mean_z + log_dem_cv_dens_z +
log_slope_cv_dens_z + log_lst_cv_temp_dens_z,
data = modelo_df_balanceado,
family = binomial()
)
# Agrega predicción y residuales a modelo_df_balanceado
modelo_df_balanceado <- modelo_df_balanceado |>
mutate(
prob_hot_bal = predict(glm_hot_bal, type = "response"),
resid_hot_bal = residuals(glm_hot_bal, type = "response")
)
# Reporta ajuste
summary(glm_hot_bal)
performance::r2_tjur(glm_hot_bal)
p_coeficientes <- plot_model(glm_hot_bal,
type = "est",
vline.color = "red",
show.values = TRUE,
transform = NULL,
value.offset = .3) +
labs(title = "Coeficientes estimados del modelo") +
theme_sjplot2() +
scale_color_sjplot("hero")
p_coeficientes
# Guarda la figura
ggsave(here("Figures", "coeficientes_logit_b.png"),
plot = p_coeficientes,
width = 6,
height = 3,
dpi = 350)
p_coeficientes <- plot_model(glm_hot_bal,
type = "est",
vline.color = "red",
show.values = TRUE,
transform = NULL,
value.offset = .3) +
labs(title = "Coeficientes estimados del modelo") +
theme_sjplot2() +
scale_color_sjplot("metro")
p_coeficientes
# Guarda la figura
ggsave(here("Figures", "coeficientes_logit_b.png"),
plot = p_coeficientes,
width = 6,
height = 3,
dpi = 350)
sjPlot::show_sjplot_pals()
p_coeficientes <- plot_model(glm_hot_bal,
type = "est",
vline.color = "red",
show.values = TRUE,
transform = NULL,
value.offset = .3) +
labs(title = "Coeficientes estimados del modelo") +
theme_sjplot2() +
scale_color_sjplot("eight")
p_coeficientes
# Guarda la figura
ggsave(here("Figures", "coeficientes_logit_b.png"),
plot = p_coeficientes,
width = 6,
height = 3,
dpi = 350)
p_coeficientes <- plot_model(glm_hot_bal,
type = "est",
vline.color = "red",
show.values = TRUE,
transform = NULL,
value.offset = .3) +
labs(title = "Coeficientes estimados del modelo") +
theme_sjplot2() +
scale_color_sjplot("blambus")
p_coeficientes
# Guarda la figura
ggsave(here("Figures", "coeficientes_logit_b.png"),
plot = p_coeficientes,
width = 6,
height = 3,
dpi = 350)
covars_slope |> summary()
